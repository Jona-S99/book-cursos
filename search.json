[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Apuntes varios",
    "section": "",
    "text": "Bienvenida\nEste libro electrónico viene a ser una compilación para los cursos que hago, de esta manera tengo todos mis apuntes en un solo lugar para cuando deba volver a ellos.\nEste sitio está en construcción.",
    "crumbs": [
      "Bienvenida"
    ]
  },
  {
    "objectID": "qmd/prompt_engineering/1_intro.html",
    "href": "qmd/prompt_engineering/1_intro.html",
    "title": "Prompt Engineering",
    "section": "",
    "text": "El Prompt Engineering es el arte y la ciencia de diseñar instrucciones efectivas para modelos de lenguaje de inteligencia artificial. Esta disciplina emergente se centra en cómo formular, estructurar y refinar los “prompts” (instrucciones o peticiones) que se proporcionan a los modelos de IA para obtener los resultados más precisos, útiles y relevantes.\nEn esencia, un ingeniero de prompts desarrolla habilidades para:\n\nFormular instrucciones claras y específicas\nProporcionar el contexto adecuado\nEstructurar las peticiones para maximizar la calidad de las respuestas\nGuiar al modelo hacia el formato y estilo deseado\nSuperar las limitaciones inherentes de los sistemas de IA\n\nEl Prompt Engineering se ha convertido en una habilidad esencial para aprovechar al máximo el potencial de los modelos de lenguaje en sus flujos de trabajo.\nImportancia del Prompt Engineering\n\nEficiencia: obtener respuestas precisas y útiles en menos iteraciones\nPersonalización: adaptar las respuestas a necesidades específicas\nSuperación de limitaciones: minimizar errores, sesgos o confusiones del modelo\nCasos de uso avanzados: habilitar aplicaciones complejas que serían imposibles con prompts básicos\n\nEste apartado refiere a los apuntes hechos del curso Prompt Engineering de Platzi.",
    "crumbs": [
      "Prompt Engineering"
    ]
  },
  {
    "objectID": "qmd/prompt_engineering/zero_shot.html",
    "href": "qmd/prompt_engineering/zero_shot.html",
    "title": "Zero-Shot",
    "section": "",
    "text": "¿Qué es el Zero-Shot Prompting?\nEl Zero-Shot Prompting es una técnica que permite obtener respuestas específicas de un modelo de lenguaje (LLM) proporcionándole únicamente una instrucción directa y sin ejemplos previamente definidos. Este método es ideal cuando se necesitan respuestas inmediatas y claras sin mostrar al modelo ejemplos anteriores de lo que se espera.",
    "crumbs": [
      "Prompt Engineering",
      "Zero-Shot"
    ]
  },
  {
    "objectID": "qmd/prompt_engineering/zero_shot.html#cuándo-usar-zero-shot-prompting",
    "href": "qmd/prompt_engineering/zero_shot.html#cuándo-usar-zero-shot-prompting",
    "title": "Zero-Shot",
    "section": "¿Cuándo usar Zero-Shot Prompting?",
    "text": "¿Cuándo usar Zero-Shot Prompting?\nEl Zero-Shot Prompting es útil en situaciones donde:\n\nSe requiere una respuesta rápida\nNo se dan ejemplos previos al modelo, solo se le da una instrucción directa.",
    "crumbs": [
      "Prompt Engineering",
      "Zero-Shot"
    ]
  },
  {
    "objectID": "qmd/prompt_engineering/zero_shot.html#conceptos-clave-para-un-buen-zero-shot-prompt",
    "href": "qmd/prompt_engineering/zero_shot.html#conceptos-clave-para-un-buen-zero-shot-prompt",
    "title": "Zero-Shot",
    "section": "Conceptos Clave para un Buen Zero-Shot Prompt",
    "text": "Conceptos Clave para un Buen Zero-Shot Prompt\n\nEnfoque: definir claramente la tarea a realizar.\n\nEjemplo: “Ayúdame a planear mis vacaciones con mi esposa.”.\n\nContexto: información adicional que debe tener en cuenta el LLM desde el inicio.\n\nEjemplo: “Tenemos la idea de ir a Europa, pero no sabemos qué países reqiueren visa.”.\n\nLímites: cosas que puede o no puede hacer el LLM.\nRol: definir el perfil que debe asumir el LLM, como un agente de viajes.",
    "crumbs": [
      "Prompt Engineering",
      "Zero-Shot"
    ]
  },
  {
    "objectID": "qmd/prompt_engineering/zero_shot.html#técnica-paso-a-paso",
    "href": "qmd/prompt_engineering/zero_shot.html#técnica-paso-a-paso",
    "title": "Zero-Shot",
    "section": "Técnica “Paso a Paso”",
    "text": "Técnica “Paso a Paso”\nSí uno le inidica al modelo que piense o realice la tarea paso a paso, el LLM razonará un plan para resolver la tarea que le estamos pidiendo.\n\nCon la técnica: hace más preguntas, más estructura tipo cuestionario.\nSin la técnica: puede asumir muchas cosas sin preguntar y limitar opciones.",
    "crumbs": [
      "Prompt Engineering",
      "Zero-Shot"
    ]
  },
  {
    "objectID": "qmd/prompt_engineering/zero_shot.html#técnica-de-agregar-etiquetas-xml",
    "href": "qmd/prompt_engineering/zero_shot.html#técnica-de-agregar-etiquetas-xml",
    "title": "Zero-Shot",
    "section": "Técnica de agregar etiquetas XML",
    "text": "Técnica de agregar etiquetas XML\nUtilizar etiquetas XML permite clarificar con precisión dónde comienzan y finalizan ciertas partes del prompt. Dado que estas etiquetas estructuran claramente el texto, reducen la posibilidad de confusión y facilitan la interpretación correcta del prompt por parte del modelo.\nUn ejemplo:\n\nDefinicion de secciones:\n\n&lt;Instrucciones&gt;\nCrea un plan para unas vacaciones en pareja.\nComo agente de viajes, realizame las preguntas pertinentes para crear el\nplan de vacaciones.\nDa al usuario varias opciones de planes, antes de crear un itinerario.\nUna vez generado el intinerario, crea una lista de requisitios para el viaje\ncomo: visas, vuelos, hoteles entre otros.\nPiensa paso a paso.\n&lt;/Instrucciones&gt;\n\n&lt;contexto&gt;\nEste plan de viaje es para chilenos.\nEl destino debe estar en Europa.\n&lt;/contexto&gt;",
    "crumbs": [
      "Prompt Engineering",
      "Zero-Shot"
    ]
  },
  {
    "objectID": "qmd/prompt_engineering/zero_shot.html#en-resumen-consideraciones-para-refinar-un-prompt",
    "href": "qmd/prompt_engineering/zero_shot.html#en-resumen-consideraciones-para-refinar-un-prompt",
    "title": "Zero-Shot",
    "section": "En resumen: consideraciones para refinar un prompt",
    "text": "En resumen: consideraciones para refinar un prompt\n\nClaridad en el rol: Define claramente el rol que el LLM debe asumir (por ejemplo, “actúa como un agente de viajes”).\nInstrucciones específicas: Proporciona instrucciones claras y directas sobre lo que deseas que haga el modelo, evita ser vago.\nFlexibilidad en preguntas: permite que el modelo formule preguntas abiertas para obtener más información pertinente.\nPensamiento paso a paso: indica que el modelo debe desglosar el problema en pasos más pequeños, facilitando una respuesta más estructurada.\nDelimitación de contexto: usa etiquetas o delimitadores (sin programación) para separar instrucciones, contexto y reglas, mejorando la comprensión del modelo.",
    "crumbs": [
      "Prompt Engineering",
      "Zero-Shot"
    ]
  },
  {
    "objectID": "qmd/prompt_engineering/few_shot.html",
    "href": "qmd/prompt_engineering/few_shot.html",
    "title": "FewShot",
    "section": "",
    "text": "¿Cuándo utilizar FewShot en vez de ZeroShot?\nEn inteligencia artificial, FewShot es una estrategia que ayuda al modelo a entender con claridad lo que deseas al incluir ejemplos específicos en las instrucciones. A diferencia de ZeroShot, que es más abierta y general, FewShot permite solucionar problemas complejos pero definidos, proporcionando ejemplos claros que guían los resultados.\nZeroShot es ideal cuando buscas flexibilidad y creatividad en respuestas amplias y subjetivas, como diseñar un plan de vacaciones a medida. FewShot, por otro lado, destaca en tareas específicas y complejas donde se necesitan respuestas claras y precisas, como clasificar correctamente opiniones en positivas, negativas o neutras.",
    "crumbs": [
      "Prompt Engineering",
      "FewShot"
    ]
  },
  {
    "objectID": "qmd/prompt_engineering/few_shot.html#ejemplo-de-uso-clasificación-de-comentarios-con-fewshot",
    "href": "qmd/prompt_engineering/few_shot.html#ejemplo-de-uso-clasificación-de-comentarios-con-fewshot",
    "title": "FewShot",
    "section": "Ejemplo de uso: clasificación de comentarios con FewShot",
    "text": "Ejemplo de uso: clasificación de comentarios con FewShot\nPara emplear FewShot y diferenciar los comentarios que recibes, sigue estos pasos:\n\nDefine indicaciones claras: dile al modelo que actúe como analista de sentimientos, identificando comentarios positivos, negativos o neutrales según la opinión expresada.\nIncluye ejemplos prácticos: proporciona ejemplos breves y claros que demuestren qué consideras positivo, negativo o neutro.\nUtiliza un formato consistente: emplea etiquetas claras para pisos y techos de los ejemplos facilitando al modelo la identificación de los límites.\n\nUn ejemplo puede ser:\n&lt;reglas&gt;\nResponde solo con la palabra neutral, positiva o negativa.\n&lt;/reglas&gt;\n\n&lt;ejemplo&gt;\nComentario: “La comida fue pésima”.\nCalificación: negativa.\n&lt;/ejemplo&gt;\n\n&lt;ejemplo&gt;\nComentario: “El servicio estuvo increíble y la comida deliciosa”.\nCalificación: positiva.\n&lt;/ejemplo&gt;\n\n&lt;ejemplo&gt;\nComentario: “El servicio fue bueno, pero la comida estuvo muy regular”.\nCalificación: neutral.\n&lt;/ejemplo&gt;",
    "crumbs": [
      "Prompt Engineering",
      "FewShot"
    ]
  },
  {
    "objectID": "qmd/prompt_engineering/few_shot.html#importancia-de-los-ejemplos-en-fewshot",
    "href": "qmd/prompt_engineering/few_shot.html#importancia-de-los-ejemplos-en-fewshot",
    "title": "FewShot",
    "section": "Importancia de los ejemplos en FewShot",
    "text": "Importancia de los ejemplos en FewShot\nCada ejemplo que incluyas enseña al modelo a distinguir con exactitud lo que quieres decir, dando una guía práctica y clara para identificar sentimientos y evitar ambigüedades. Recuerda que cada palabra y detalle influye notablemente en el resultado, por lo que una buena elección de ejemplos impacta positivamente en la efectividad final del modelo.\n\n¿Cuántos ejemplos debo incluir en mi prompt?\nPoner muchos o pocos ejemplos dependerá del rendimiento deseado y la complejidad del problema:\n\nCada ejemplo consume tokens y va a afectar el costo del uso.\nA mayor cantidad de ejemplos, más precisa será la calificación al detalle.\n\n\n\n\n\n\n\nTip\n\n\n\nLo recomendable es iniciar con algunos ejemplos clave e ir agregando aquellos donde identifiques errores previos para mejorar continuamente los resultados.",
    "crumbs": [
      "Prompt Engineering",
      "FewShot"
    ]
  },
  {
    "objectID": "qmd/prompt_engineering/few_shot.html#cómo-puedo-validar-los-resultados-de-mi-análisis",
    "href": "qmd/prompt_engineering/few_shot.html#cómo-puedo-validar-los-resultados-de-mi-análisis",
    "title": "FewShot",
    "section": "¿Cómo puedo validar los resultados de mi análisis?",
    "text": "¿Cómo puedo validar los resultados de mi análisis?\nRealiza pruebas constantes ajustando detalles del prompt como las comillas o etiquetas y verificando si los resultados varían. Mediante ensayos controlados, puedes detectar y corregir errores eficientemente, garantizando que el modelo entienda con precisión tu requerimiento.",
    "crumbs": [
      "Prompt Engineering",
      "FewShot"
    ]
  },
  {
    "objectID": "qmd/prompt_engineering/chain_of_thought.html",
    "href": "qmd/prompt_engineering/chain_of_thought.html",
    "title": "Chain of thought o cadena de pensamiento",
    "section": "",
    "text": "La técnica de prompting Chain of Thought, o cadena de pensamiento, mejora significativamente la calidad de respuesta de los modelos de lenguaje como ChatGPT. Aplicar este método implica guiar paso a paso las respuestas mediante instrucciones claras, para obtener resultados más precisos y coherentes. Veamos qué implica esta técnica y cómo sacarle el máximo provecho.\nChain of Thought consiste en pedir al modelo que explique, paso por paso, cómo llega a una respuesta determinada, especialmente ante preguntas que requieren razonamiento lógico. Antes de contar con modelos avanzados, era necesario indicar explícitamente en los prompts que “pensaran paso a paso”; los modelos actuales con capacidad de razonamiento avanzado ya operan bajo esta lógica por defecto.\nEsta técnica mejora los resultados, pero necesita un mayor tiempo de procesamiento por parte del modelo.\n\n¿Cuándo conviene usar chain of thougth?\n\nResolución lógica de acertijos.\nProcedimientos matemáticos y científicos que siguen un orden definido. Por ejemplo, resolver ecuaciones siguiendo reglas establecidas como la jerarquía de operaciones matemáticas (primero paréntesis, luego multiplicación y división, finalmente suma y resta).\n\nEjemplo práctico\n[CONTEXTO]\nNecesito resolver el siguiente problema matemático: Un tren A sale de Madrid a las 8:00 AM viajando a 120 km/h hacia Valencia. Un tren B sale de Valencia a las 9:30 AM viajando a 90 km/h hacia Madrid. Si la distancia entre Madrid y Valencia es de 360 km, ¿a qué hora se cruzarán los trenes?\n\n[INSTRUCCIÓN EXPLÍCITA CON CHAIN OF THOUGHT]\nPor favor, resuelve este problema paso a paso. Piensa de forma estructurada:\n1. Identifica los datos relevantes\n2. Plantea las ecuaciones necesarias\n3. Resuelve algebraicamente\n4. Verifica tu respuesta\n\n[FORMATO DESEADO]\nMuestra cada uno de tus pasos de razonamiento y explica por qué sigues ese enfoque. Finaliza con una conclusión clara que responda directamente a la pregunta.",
    "crumbs": [
      "Prompt Engineering",
      "Chain of thought o cadena de pensamiento"
    ]
  },
  {
    "objectID": "qmd/prompt_engineering/meta_prompting.html",
    "href": "qmd/prompt_engineering/meta_prompting.html",
    "title": "Meta prompting",
    "section": "",
    "text": "Casos de uso:\nEl meta-prompting es una técnica avanzada de prompt engineering donde se instruye al modelo de lenguaje para que genere, refine o evalúe prompts. En lugar de pedir directamente una respuesta a una tarea, se le pide al modelo que actúe como un “ingeniero de prompts” o un “asistente de creación de prompts”, ayudando a construir el prompt óptimo para una tarea específica. Esta técnica es útil cuando se busca mejorar la calidad de los prompts existentes, generar variaciones de prompts para probar diferentes enfoques, o incluso para que el modelo explique por qué un prompt particular podría ser más efectivo que otro.",
    "crumbs": [
      "Prompt Engineering",
      "Meta prompting"
    ]
  },
  {
    "objectID": "qmd/prompt_engineering/meta_prompting.html#casos-de-uso",
    "href": "qmd/prompt_engineering/meta_prompting.html#casos-de-uso",
    "title": "Meta prompting",
    "section": "",
    "text": "Optimización de Prompts: Mejorar un prompt existente para obtener mejores respuestas.\nGeneración de Variaciones de Prompts: Crear múltiples versiones de un prompt para A/B testing o para cubrir diferentes matices de una tarea.\nAnálisis de Prompts: Pedir al modelo que evalúe la efectividad de un prompt y sugiera mejoras.\nCreación de Prompts para Tareas Complejas: Guiar al modelo para que construya un prompt detallado para una tarea que requiere múltiples consideraciones.\nEducación en Prompt Engineering: Usar el modelo para que enseñe cómo construir buenos prompts.",
    "crumbs": [
      "Prompt Engineering",
      "Meta prompting"
    ]
  },
  {
    "objectID": "qmd/prompt_engineering/meta_prompting.html#por-qué-es-importante-refinar-un-prompt",
    "href": "qmd/prompt_engineering/meta_prompting.html#por-qué-es-importante-refinar-un-prompt",
    "title": "Meta prompting",
    "section": "¿Por qué es importante refinar un prompt?",
    "text": "¿Por qué es importante refinar un prompt?\nCrear un prompt efectivo va más allá de agregar más instrucciones o reglas. Modificar palabras y comprender claramente su significado es clave para obtener resultados precisos usando inteligencia artificial. Este método de refinamiento puede aplicarse a diversas profesiones y tareas cotidianas.",
    "crumbs": [
      "Prompt Engineering",
      "Meta prompting"
    ]
  },
  {
    "objectID": "qmd/prompt_engineering/meta_prompting.html#ejemplo-de-meta-promt",
    "href": "qmd/prompt_engineering/meta_prompting.html#ejemplo-de-meta-promt",
    "title": "Meta prompting",
    "section": "Ejemplo de Meta promt",
    "text": "Ejemplo de Meta promt\n[ROL]\nEres un experto en Prompt Engineering especializado en la creación de prompts para modelos de lenguaje generativos de texto.\n\n[TAREA]\nQuiero generar descripciones de productos concisas y persuasivas para una tienda online de artículos de tecnología. El público objetivo son jóvenes adultos interesados en las últimas novedades.\n\n[INSTRUCCIÓN DE META-PROMPTING]\nPor favor, crea tres variaciones de un prompt que yo pueda usar con un modelo como ChatGPT para generar estas descripciones de producto. Cada prompt debe:\n1. Especificar el tono deseado (moderno, entusiasta).\n2. Indicar la longitud aproximada de la descripción (ej. 2-3 frases).\n3. Solicitar que se destaquen 1-2 características clave del producto.\n4. Incluir un placeholder para el [NOMBRE_DEL_PRODUCTO] y [CARACTERISTICAS_CLAVE].\n\n[FORMATO DESEADO]\nPresenta cada variación del prompt claramente numerada.",
    "crumbs": [
      "Prompt Engineering",
      "Meta prompting"
    ]
  },
  {
    "objectID": "qmd/prompt_engineering/prompt_chaining.html",
    "href": "qmd/prompt_engineering/prompt_chaining.html",
    "title": "Prompt chaining",
    "section": "",
    "text": "El Prompt Chaining se basa en descomponer grandes retos en partes pequeñas que manejas individualmente en múltiples chats. A diferencia de lo habitual, donde mantienes todo dentro de un solo chat, esta técnica implica tomar cada resultado logrado y moverlo a un nuevo chat específico, garantizando mayor claridad y menos errores.",
    "crumbs": [
      "Prompt Engineering",
      "Prompt chaining"
    ]
  },
  {
    "objectID": "qmd/python/1_intro_py.html",
    "href": "qmd/python/1_intro_py.html",
    "title": "Python",
    "section": "",
    "text": "Introducción de python",
    "crumbs": [
      "Python"
    ]
  },
  {
    "objectID": "qmd/python/strings.html",
    "href": "qmd/python/strings.html",
    "title": "1  Strings o cadenas",
    "section": "",
    "text": "¿Cómo se definen las cadenas en Python?\nEntender cómo trabajar con las cadenas en Python es fundamental para la manipulación de textos y datos en muchos proyectos. Desde definir variables hasta aplicar métodos específicos, el uso de strings es una habilidad básica, pero poderosa, que se utiliza en áreas avanzadas como el procesamiento del lenguaje natural (NLP).\nPara crear una cadena en Python, puedes utilizar comillas simples, dobles o triples. Por ejemplo:\n# Comillas simples\nnombre_cs = 'Juan Rosas'\nprint('String con comillas simples: ', nombre_cs)\n\nString con comillas simples:  Juan Rosas\n# Comillas dobles\nnombre_cd = \"Juan Rosas\"\nprint('String con comillas dobles: ', nombre_cd)\n\nString con comillas dobles:  Juan Rosas\n# Comillas triples: acepta saltos de linea\nnombre_tc = '''\nJuan\nRosas\n'''\nprint('String con comillas triples: ', nombre_tc)\n\nString con comillas triples:  \nJuan\nRosas",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Strings o cadenas</span>"
    ]
  },
  {
    "objectID": "qmd/python/strings.html#métodos-para-strings",
    "href": "qmd/python/strings.html#métodos-para-strings",
    "title": "1  Strings o cadenas",
    "section": "Métodos para strings",
    "text": "Métodos para strings\n\n.lower\nConvierte todos los caracteres a minúsculas.\n\ns = \"Hola Mundo\"\nprint(s.lower())  # 'hola mundo'\n\n\n\n.upper\nConvierte todos los caracteres a mayúsculas.\n\ns = \"Hola Mundo\"\nprint(s.upper())  # 'HOLA MUNDO'\n\n\n\n.capitalize\nPone en mayúscula la primera letra y el resto en minúsculas.\n\ns = \"hOLA\"\nprint(s.capitalize())  # 'Hola'\n\n\n\n.title\nCapitaliza la primera letra de cada palabra.\n\ns = \"hola mundo\"\nprint(s.title())  # 'Hola Mundo'\n\n\n\n.swapcase\nInvierte el caso de cada carácter.\n\ns = \"Hola Mundo\"\nprint(s.swapcase())  # 'hOLA mUNDO'\n\n\n\n.strip(), .lstrip(), .rstrip()\nElimina espacios (u otros caracteres) al inicio/final de la cadena.\n\ns = \"  ejemplo  \"\nprint(s.strip())   # 'ejemplo'\nprint(s.lstrip())  # 'ejemplo  '\nprint(s.rstrip())  # '  ejemplo'\n\n\n\n.split(sep=None), .rsplit(sep=None)\nDivide la cadena en una lista según el separador.\n\ns = \"a,b,c\"\nprint(s.split(\",\"))   # ['a', 'b', 'c']\nprint(s.rsplit(\",\", 1))  # ['a,b', 'c']\n\n\n\n.join(iterable)\nUne los elementos de un iterable usando la cadena como separador.\n\nparts = [\"Python\", \"es\", \"genial\"]\nprint(\" \".join(parts))  # 'Python es genial'\n\n\n\n.replace(old, new)\nReemplaza todas las ocurrencias de old por new.\n\ns = \"2025-05-29\"\nprint(s.replace(\"-\", \"/\"))  # '2025/05/29'\n\n\n\n.find(sub), .index(sub)\nDevuelven el índice de la primera aparición de sub (–1 si no existe en find, excepción en index).\n\ns = \"abcdef\"\nprint(s.find(\"cd\"))   # 2\n# print(s.index(\"xy\"))  # ValueError\n\n\n\n.count(sub)\nCuenta cuántas veces aparece sub.\n\ns = \"banana\"\nprint(s.count(\"a\"))  # 3\n\n\n\n.startswith(pref), .endswith(suf)\nComprueban si la cadena empieza o termina con el prefijo/sufijo dado.\n\ns = \"Hola.py\"\nprint(s.startswith(\"Ho\"))  # True\nprint(s.endswith(\".py\"))   # True\n\n\n\n.isalpha(), .isdigit(), .isalnum(), .isspace()\nValidaciones de contenido: solo letras, dígitos, alfanumérico o espacios.\n\nprint(\"abc\".isalpha())   # True\nprint(\"123\".isdigit())   # True\nprint(\"a1b2\".isalnum())  # True\nprint(\" \\t\".isspace())   # True\n\n\n\n.zfill(width)\nRellena con ceros a la izquierda hasta lograr el ancho width.\n\nprint(\"42\".zfill(5))  # '00042'\n\n\n\n.center(width, [fillchar])\nCentra la cadena en un ancho dado, rellenando con fillchar (espacio por defecto).\n\nprint(\"cat\".center(7, \"-\"))  # '--cat--'\n\n\n\n.partition(sep), .rpartition(sep)\nDivide en tres partes: antes de sep, sep, después de sep.\n\ns = \"key=value\"\nprint(s.partition(\"=\"))   # ('key', '=', 'value')\nprint(s.rpartition(\"o\"))  # ('hell', 'o', '')\n\n\n\n.format(args, kwargs)\nFormatea la cadena usando llaves como marcadores.\n\nargs (argumentos posicionales) se usan para rellenar marcadores {} o {0}, {1}, … según el orden.\nkwargs (argumentos nombrados) se usan para rellenar marcadores {nombre}.\n\n\ntpl = \"Hola, {}. Tienes {n} mensajes.\"\nprint(tpl.format(\"Ana\", n=5))  # 'Hola, Ana. Tienes 5 mensajes.'",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Strings o cadenas</span>"
    ]
  },
  {
    "objectID": "qmd/python/int_float_bool.html",
    "href": "qmd/python/int_float_bool.html",
    "title": "2  Integer, Float, Boolean",
    "section": "",
    "text": "Operaciones aritméticas\nEn Python, los tipos de datos numéricos son esenciales para representar valores cuantitativos y realizar operaciones matemáticas. Entre los tipos numéricos básicos se encuentran:\n# Definición de variables\na = 7\nb = 3.5\n\nprint(a + b)    # Suma:           10.5\nprint(a - b)    # Resta:           3.5\nprint(a * b)    # Multiplicación:  24.5\nprint(a / b)    # División real:   2.0\nprint(a // b)   # División entera: 2.0\nprint(a % b)    # Módulo:          0.0\nprint(a ** b)   # Exponente:       ≈ 643.397",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Integer, Float, Boolean</span>"
    ]
  },
  {
    "objectID": "qmd/python/int_float_bool.html#conversión-entre-tipos",
    "href": "qmd/python/int_float_bool.html#conversión-entre-tipos",
    "title": "2  Integer, Float, Boolean",
    "section": "Conversión entre tipos",
    "text": "Conversión entre tipos\n\nf = 3.14\nn = int(f)      # Convierte float a int (trunca parte decimal)\nprint(n)        # 3\n\ns = \"42\"\nm = int(s)      # Convierte str a int\nprint(m + 8)    # 50",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Integer, Float, Boolean</span>"
    ]
  },
  {
    "objectID": "qmd/python/int_float_bool.html#algunas-funciones-integradas-útiles",
    "href": "qmd/python/int_float_bool.html#algunas-funciones-integradas-útiles",
    "title": "2  Integer, Float, Boolean",
    "section": "Algunas funciones integradas útiles",
    "text": "Algunas funciones integradas útiles\n\nprint(abs(-5))        # Valor absoluto: 5\nprint(pow(2, 3))      # Potencia: 8\nprint(divmod(7, 3))   # División entera y resto: (2, 1)\nprint(round(3.6))     # Redondeo: 4",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Integer, Float, Boolean</span>"
    ]
  },
  {
    "objectID": "qmd/python/operadores.html",
    "href": "qmd/python/operadores.html",
    "title": "3  Operadores",
    "section": "",
    "text": "Operadores aritméticos\nLos operadores son herramientas esenciales en Python para realizar operaciones con diferentes tipos de datos. Existen distintos tipos de operadores:",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Operadores</span>"
    ]
  },
  {
    "objectID": "qmd/python/operadores.html#operadores-aritméticos",
    "href": "qmd/python/operadores.html#operadores-aritméticos",
    "title": "3  Operadores",
    "section": "",
    "text": "Operación\nSímbolo\nDescripción\nEjemplo\nResultado\n\n\n\n\nSuma\n+\nSuma dos operandos.\n5 + 3\n8\n\n\nResta\n-\nResta un operando del otro.\n5 - 3\n2\n\n\nMultiplicación\n*\nMultiplica dos operandos.\n5 * 3\n15\n\n\nDivisión\n/\nDivide un operando por otro.\n6 / 3\n2\n\n\nDivisión entera\n//\nDivide dos operandos y devuelve la parte entera del resultado.\n7 // 3\n2",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Operadores</span>"
    ]
  },
  {
    "objectID": "qmd/python/operadores.html#operadores-relacionales",
    "href": "qmd/python/operadores.html#operadores-relacionales",
    "title": "3  Operadores",
    "section": "Operadores relacionales",
    "text": "Operadores relacionales\n\n\n\n\n\n\n\n\n\n\nOperación\nSímbolo\nDescripción\nEjemplo\nResultado\n\n\n\n\nIgualdad\n=\nComprueba si dos operandos son iguales.\n5 = 5\nTRUE\n\n\nDesigualdad\n#\nComprueba si dos operandos son diferentes.\n5 # 3\nTRUE\n\n\nMenor que\n&lt;\nComprueba si un operando es menor que el otro.\n3 &lt; 5\nTRUE\n\n\nMenor o igual que\n&lt;=\nComprueba si un operando es menor o igual que el otro.\n5 &lt;= 5\nTRUE\n\n\nMayor que\n&gt;\nComprueba si un operando es mayor que el otro.\n5 &gt; 3\nTRUE\n\n\nMayor o igual que\n&gt;=\nComprueba si un operando es mayor o igual que el otro.\n5 &gt;= 6\nFALSE",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Operadores</span>"
    ]
  },
  {
    "objectID": "qmd/python/operadores.html#operadores-de-asignación",
    "href": "qmd/python/operadores.html#operadores-de-asignación",
    "title": "3  Operadores",
    "section": "Operadores de Asignación",
    "text": "Operadores de Asignación\n\n\n\n\n\n\n\n\n\n\nOperación\nSímbolo\nDescripción\nEjemplo\nResultado\n\n\n\n\nAsignación simple\n=\nAsigna un valor a una variable.\nx = 5\nx = 5\n\n\nSuma y asignación\n+=\nSuma un valor a una variable existente.\nx = 5; x += 3\nx = 8\n\n\nResta y asignación\n-=\nResta un valor a una variable existente.\nx = 5; x -= 2\nx = 3\n\n\nMultiplicación y asignación\n*=\nMultiplica un valor a una variable existente.\nx = 4; x *= 2\nx = 8\n\n\nDivisión y asignación\n/=\nDivide un valor a una variable existente.\nx = 10; x /= 2\nx = 5\n\n\nMódulo y asignación\n%=\nObtiene el residuo de la división y lo asigna a una variable existente.\nx = 10; x %= 4\nx = 2\n\n\nExponenciación y asignación\n**=\nEleva un valor a la potencia del otro y lo asigna a una variable existente.\nx = 2; x **= 3\nx = 8",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Operadores</span>"
    ]
  },
  {
    "objectID": "qmd/python/input_casting.html",
    "href": "qmd/python/input_casting.html",
    "title": "4  Input y Casting",
    "section": "",
    "text": "Función input()\nEn Python, cuando trabajamos con proyectos que requieren interacción del usuario, es común solicitar datos como correo o contraseña para ejecutar acciones específicas. Este mismo enfoque es útil para entender la función input().\n# Sin mensaje personalizado\nnombre = input()\nprint(\"Hola\", nombre)\n\n# Con mensaje\nedad = input(\"¿Cuántos años tienes? \")\nprint(\"Vas a cumplir\", edad, \"este año.\")",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Input y Casting</span>"
    ]
  },
  {
    "objectID": "qmd/python/input_casting.html#función-input",
    "href": "qmd/python/input_casting.html#función-input",
    "title": "4  Input y Casting",
    "section": "",
    "text": "Detiene la ejecución del programa y muestra un mensaje en pantalla (opcional). Luego espera a que el usuario escriba texto y presione Enter.\n\n\n\n\n\n\n\n\nNote\n\n\n\nEn ambos casos nombre y edad serán variables de tipo str.",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Input y Casting</span>"
    ]
  },
  {
    "objectID": "qmd/python/input_casting.html#qué-es-el-casting-conversión-de-tipos",
    "href": "qmd/python/input_casting.html#qué-es-el-casting-conversión-de-tipos",
    "title": "4  Input y Casting",
    "section": "¿Qué es el casting (conversión de tipos)?",
    "text": "¿Qué es el casting (conversión de tipos)?\nCasting es el proceso de convertir un valor de un tipo de dato a otro. En Python, esto se hace normalmente llamando al constructor del tipo deseado:\n\nint(valor) → convierte a entero (trunca decimales o produce error si no es numérico).\nfloat(valor) → convierte a número de punto flotante.\nstr(valor) → convierte cualquier valor a cadena de texto.\nbool(valor) → convierte a booleano (False si el valor es “vacío” o cero).\n\nEjemplos:\n\n# Pedimos la edad, la recibimos como str y la convertimos a int\nedad_str = input(\"¿Cuántos años tienes? \")\nedad = int(edad_str)    \nprint(\"El año que viene tendrás\", edad + 1, \"años.\")\n\n# Pedimos un número decimal y lo convertimos a float\nnota_str = input(\"¿Qué nota obtuviste? \")\nnota = float(nota_str)\nprint(\"Has sacado un\", nota, \"en la nota final.\")\n\nEn estos ejemplos:\n\ninput() lee siempre una cadena.\nAplicamos int(...) o float(...) para poder usar operaciones aritméticas con el valor ingresado.\nSi el usuario introduce un texto no convertible (por ejemplo “hola” al hacer int(“hola”)), Python lanzará un ValueError.",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Input y Casting</span>"
    ]
  },
  {
    "objectID": "qmd/python/listas.html",
    "href": "qmd/python/listas.html",
    "title": "5  Listas",
    "section": "",
    "text": "5.1 Métodos para listas\nUna lista en Python es una colección ordenada de elementos que puede contener elementos de diferentes tipos (enteros, flotantes, cadenas, etc.). Las listas son mutables, lo que significa que sus elementos se pueden cambiar después de que se ha creado la lista.\nPara crear una lista utilizamos los corchetes []",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Listas</span>"
    ]
  },
  {
    "objectID": "qmd/python/listas.html#métodos-para-listas",
    "href": "qmd/python/listas.html#métodos-para-listas",
    "title": "5  Listas",
    "section": "",
    "text": "append(item)\nAñade un elemento item al final de la lista.\n\nlista = [1, 2, 3]\nlista.append([\"a\", \"b\", \"c\"])\nprint(lista)  # [1, 2, 3, 4]\n\n[1, 2, 3, ['a', 'b', 'c']]\n\n\n\n\ninsert(index, item)\nInserta item en la posición index, desplazando el resto a la derecha.\n\nlista = ['a', 'b', 'd']\nlista.insert(2, 'c')\nprint(lista)  # ['a', 'b', 'c', 'd']\n\n['a', 'b', 'c', 'd']\n\n\n\n\nremove(item)\nElimina la primera aparición de item en la lista. Lanza ValueError si no existe.\n\nlista = [1, 2, 3, 2]\nlista.remove(2)\nprint(lista)  # [1, 3, 2]\n\n[1, 3, 2]\n\n\n\n\nclear()\nElimina todos los elementos de la lista, dejándola vacía.\n\nlista = [1, 2, 3]\nlista.clear()\nprint(lista)  # []\n\n[]\n\n\n\n\ncount(item)\nCuenta cuántas veces aparece item en la lista.\n\nlista = [1, 2, 2, 2, 3]\nprint(\"El valor 2 se repite \", lista.count(2), \" veces en la lista\")  # 3\n\nEl valor 2 se repite  3  veces en la lista\n\n\n\n\nsort(key=None, reverse=False)\nOrdena la lista in place.\n\nkey: función para extraer el valor de comparación.\nreverse=True: orden descendente.\n\n\nlista = [3, 1, 2]\nlista.sort()\nprint(lista)  # [1, 2, 3]\n\nlista = ['b', 'aa', 'ccc']\nlista.sort(key=len, reverse=True)\nprint(lista)  # ['ccc', 'aa', 'b']\n\n[1, 2, 3]\n['ccc', 'aa', 'b']\n\n\n\n\nreverse()\nInvierte el orden de los elementos in place.\n\nlista = [1, 2, 3]\nlista.reverse()\nprint(lista)  # [3, 2, 1]\n\n[3, 2, 1]",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Listas</span>"
    ]
  },
  {
    "objectID": "qmd/python/listas.html#copiar-una-lista",
    "href": "qmd/python/listas.html#copiar-una-lista",
    "title": "5  Listas",
    "section": "5.2 Copiar una lista",
    "text": "5.2 Copiar una lista\n\n\n\n\n\n\nNote\n\n\n\nCuando asignamos una lista a una nueva variable, por ejemplo, B = A, no estamos creando una copia independiente. Ambas variables apuntan al mismo espacio de memoria. Así, cualquier cambio en A se reflejará en B.\n\n\n\n# Crear lista\nls_a = [1, 2, 3, 4, 5]\n\n# Copiar lista\nls_b = ls_a\n\nprint(\"El id de la lista a es: \", id(ls_a))\nprint(\"El id de la lista b es: \", id(ls_b))\n\nEl id de la lista a es:  4421662272\nEl id de la lista b es:  4421662272\n\n\nComo podemos ver, son iguales, pues apuntan la mismo lugar en memoria. Entonces, ¿cómo evitamos esto?\nUitlizando el método slicing.\n\n# Crear lista c\nls_c = ls_a[:]\n\nprint(\"El id de la lista a es: \", id(ls_a))\nprint(\"El id de la lista b es: \", id(ls_c))\n\nEl id de la lista a es:  4421662272\nEl id de la lista b es:  4421663232\n\n\nComo vemos, son ids diferentes.",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Listas</span>"
    ]
  },
  {
    "objectID": "qmd/python/matrices_tuplas.html",
    "href": "qmd/python/matrices_tuplas.html",
    "title": "6  Matrices y tuplas",
    "section": "",
    "text": "6.1 Matriz\nUna matriz es una colección ordenada de datos dispuestos en filas y columnas. Se representa como una lista de listas, donde cada sublista es una fila de la matriz, es decir, una matriz es una lista de listas.\nEjemplo de matriz:\nmatrix = [\n  # Columnas\n    [1, 2, 3],  # Filas\n    [4, 5, 6],  # Filas\n    [7, 8, 9]   # Filas\n]\n# Acceder al elemento de la segunda fila, tercera columna\nprint(matrix[1][2])  # 6\n\n# Modificar un valor\nmatrix[0][0] = 10\nprint(matrix)  \n# [\n#   [10, 2, 3],\n#   [4, 5, 6],\n#   [7, 8, 9]\n# ]",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Matrices y tuplas</span>"
    ]
  },
  {
    "objectID": "qmd/python/matrices_tuplas.html#matriz",
    "href": "qmd/python/matrices_tuplas.html#matriz",
    "title": "6  Matrices y tuplas",
    "section": "",
    "text": "Sitaxis: como se trata de listas, se crean utilizando corchetes []\nMutable: puedes modificar elementos, añadir o quitar filas/columnas.\nSe accede por doble índice: matrix[fila][columna].\nÚtil para datos bidimensionales (tablas, imágenes, operaciones numéricas).\nSe usa cuando necesitas una secuencia de elementos que puede cambiar a lo largo del programa.",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Matrices y tuplas</span>"
    ]
  },
  {
    "objectID": "qmd/python/matrices_tuplas.html#tuplas",
    "href": "qmd/python/matrices_tuplas.html#tuplas",
    "title": "6  Matrices y tuplas",
    "section": "6.2 Tuplas",
    "text": "6.2 Tuplas\nUna tupla es una secuencia ordenada e inmutable de elementos:\n\nnumbers = (1, 2, 3, 4, 5)\n\nprint(\"El tipo de numbers es: \", type(numbers))\n\nEl tipo de numbers es:  &lt;class 'tuple'&gt;\n\n\n\nSintaxis: se crea usando paréntesis (). Ejemplo: tupla = (1, 2, 3).\nInmutable: no puedes cambiar su contenido una vez creada.\nMás ligera que la lista y adecuada para datos fijos o como clave en diccionarios.\nSe usa cuando tienes una secuencia de elementos que no debería cambiar, o para mejorar el rendimiento, ya que las tuplas son más rápidas y consumen menos memoria que las listas.\n\n\n# Acceso por índice\nprint(numbers[1])     # '2'\n\n# No permite asignación\nnumbers[0] = 5\n# TypeError: 'tuple' object does not support item assignment",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Matrices y tuplas</span>"
    ]
  },
  {
    "objectID": "qmd/python/diccionarios.html",
    "href": "qmd/python/diccionarios.html",
    "title": "7  Diccionarios",
    "section": "",
    "text": "7.1 ¿Cómo crear un diccionario?\nLos diccionarios en Python son una estructura que almacenan dos datos, la clave y el valor. Un ejemplo cotidiano es un diccionario físico donde buscamos el significado de una palabra y encontramos la palabra (clave) y su definición (valor).\nEs importante mencionar las siguientes carecterísticas:\nPara crear un diccionario utilizamos las llaves {}.\nnumbers = {\n  1: \"one\", \n  2: \"two\",\n  3: \"three\"\n}\nprint(numbers)\n\n{1: 'one', 2: 'two', 3: 'three'}\nPara acceder a un elemento dentro del diccionario utilizamos su llave.\n# Acceder al numero 2\nprint(numbers[2])\n\ntwo",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Diccionarios</span>"
    ]
  },
  {
    "objectID": "qmd/python/diccionarios.html#modificaciones-a-los-diccionarios",
    "href": "qmd/python/diccionarios.html#modificaciones-a-los-diccionarios",
    "title": "7  Diccionarios",
    "section": "7.2 Modificaciones a los diccionarios",
    "text": "7.2 Modificaciones a los diccionarios\nModificación de valores\n\n# Modificacion de un valor\nnumbers[3] = \"tres\"\nprint(numbers[3])\n\ntres\n\n\nPara eliminar una clave y su valor utilizamos la función del\n\n# Eliminacion de la clave `3`\ndel numbers[3]\nprint(numbers)\n\n{1: 'one', 2: 'two'}",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Diccionarios</span>"
    ]
  },
  {
    "objectID": "qmd/python/diccionarios.html#métodos-para-los-diccionarios",
    "href": "qmd/python/diccionarios.html#métodos-para-los-diccionarios",
    "title": "7  Diccionarios",
    "section": "7.3 Métodos para los diccionarios",
    "text": "7.3 Métodos para los diccionarios\n\n# Diccionario para probar metodos\ndiccionario = {\n  'Nombre': 'Juan',\n  'Edad': 30,\n  'Profesion': 'Ingeniero',\n  'Ubicacion': 'Punta Arenas'\n}\n\n\nkey()\nDevuelve una vista (iterable) con todas las claves del diccionario.\n\nkey_test = diccionario.keys()\nprint(\"El restultado es: \", key_test)\nprint(\"El tipo es: \", type(key_test))\n\nEl restultado es:  dict_keys(['Nombre', 'Edad', 'Profesion', 'Ubicacion'])\nEl tipo es:  &lt;class 'dict_keys'&gt;\n\n\n\n\nvalues()\nDevuelve una vista con todos los valores del diccionario.\n\nprint(diccionario.values())\n\ndict_values(['Juan', 30, 'Ingeniero', 'Punta Arenas'])\n\n\n\n\nitems()\nDevuelve una vista de tuplas (clave, valor) para cada par del diccionario.\n\nprint(diccionario.items())\n\ndict_items([('Nombre', 'Juan'), ('Edad', 30), ('Profesion', 'Ingeniero'), ('Ubicacion', 'Punta Arenas')])\n\n\n\n\nclear()\nElimina todos los elementos del diccionario, dejándolo vacío.\n\ndiccionario.clear()\nprint(diccionario)\n\n{}",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Diccionarios</span>"
    ]
  },
  {
    "objectID": "qmd/python/if_else_elif.html",
    "href": "qmd/python/if_else_elif.html",
    "title": "8  If, Else y Elif",
    "section": "",
    "text": "8.1 IF en python\nEn programación, las estructuras condicionales son esenciales para tomar decisiones basadas en ciertas condiciones. Por ejemplo, al usar la instrucción IF en Python, se puede verificar si una variable cumple con una condición específica y ejecutar el código correspondiente.\nPara utilizar el IF, primero se define una variable, por ejemplo, x = 10. Luego, se escribe la estructura condicional usando la palabra reservada IF seguida de la condición, como if x &gt; 5:. Si esta condición es verdadera, se ejecuta el código dentro del IF, que debe estar indentado.\nx = 10\nif x &gt; 5:\n    print(\"x es mayor que 5\")\n    print(\"Indentación dentro del `if`\")\n\nprint(\"Indentación fuera del `if`\")\n\nx es mayor que 5\nIndentación dentro del `if`\nIndentación fuera del `if`",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>If, Else y Elif</span>"
    ]
  },
  {
    "objectID": "qmd/python/if_else_elif.html#if-en-python",
    "href": "qmd/python/if_else_elif.html#if-en-python",
    "title": "8  If, Else y Elif",
    "section": "",
    "text": "Tip\n\n\n\nEs importante presetar atención a la indentación al momento de utilizar estas estructuras.",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>If, Else y Elif</span>"
    ]
  },
  {
    "objectID": "qmd/python/if_else_elif.html#qué-pasa-si-la-condición-del-if-es-falsa",
    "href": "qmd/python/if_else_elif.html#qué-pasa-si-la-condición-del-if-es-falsa",
    "title": "8  If, Else y Elif",
    "section": "8.2 ¿Qué pasa si la condición del IF es falsa?",
    "text": "8.2 ¿Qué pasa si la condición del IF es falsa?\nSi la condición del IF no se cumple, se puede utilizar la instrucción else para manejar el caso contrario. Por ejemplo, si x es menor o igual a 5, se ejecutará el bloque de código dentro del else.\n\nx = 3\nif x &gt; 5:\n    print(\"x es mayor que 5\")\nelse:\n    print(\"x es menor o igual a 5\")\n\nx es menor o igual a 5",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>If, Else y Elif</span>"
    ]
  },
  {
    "objectID": "qmd/python/if_else_elif.html#cómo-se-manejan-múltiples-condiciones",
    "href": "qmd/python/if_else_elif.html#cómo-se-manejan-múltiples-condiciones",
    "title": "8  If, Else y Elif",
    "section": "8.3 ¿Cómo se manejan múltiples condiciones?",
    "text": "8.3 ¿Cómo se manejan múltiples condiciones?\nCuando hay múltiples condiciones, se puede usar elif (else if). Esto permite agregar condiciones adicionales entre if y else.\n\nx = 5\nif x &gt; 5:\n    print(\"x es mayor que 5\")\nelif x == 5:\n    print(\"x es igual a 5\")\nelse:\n    print(\"x es menor que 5\")\n\nx es igual a 5",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>If, Else y Elif</span>"
    ]
  },
  {
    "objectID": "qmd/python/if_else_elif.html#cómo-se-manejan-múltiples-condiciones-en-un-solo-if",
    "href": "qmd/python/if_else_elif.html#cómo-se-manejan-múltiples-condiciones-en-un-solo-if",
    "title": "8  If, Else y Elif",
    "section": "8.4 ¿Cómo se manejan múltiples condiciones en un solo IF?",
    "text": "8.4 ¿Cómo se manejan múltiples condiciones en un solo IF?\nPara evaluar múltiples condiciones en una sola sentencia IF, se pueden utilizar los operadores lógicos and y or. El operador and requiere que ambas condiciones sean verdaderas, mientras que el operador or requiere que al menos una condición sea verdadera.\n\nx = 15\ny = 30\n\n# Ambas son verdaderas\nif x &gt; 10 and y &gt; 25:\n    print(\"x es mayor que 10 y y es mayor que 25\")\n\n# Al menos una es verdadera\nif x &gt; 10 or y &gt; 35:\n    print(\"x es mayor que 10 o y es mayor que 35\")\n\nx es mayor que 10 y y es mayor que 25\nx es mayor que 10 o y es mayor que 35",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>If, Else y Elif</span>"
    ]
  },
  {
    "objectID": "qmd/python/if_else_elif.html#qué-es-la-negación-en-las-condiciones",
    "href": "qmd/python/if_else_elif.html#qué-es-la-negación-en-las-condiciones",
    "title": "8  If, Else y Elif",
    "section": "8.5 ¿Qué es la negación en las condiciones?",
    "text": "8.5 ¿Qué es la negación en las condiciones?\nLa palabra reservada not se utiliza para negar una condición. Si una condición es verdadera, not la convierte en falsa, y viceversa.\n\nx = 15\nif not x &gt; 20:\n    print(\"x no es mayor que 20\")\n\nx no es mayor que 20",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>If, Else y Elif</span>"
    ]
  },
  {
    "objectID": "qmd/python/if_else_elif.html#cómo-se-anidan-las-estructuras-if",
    "href": "qmd/python/if_else_elif.html#cómo-se-anidan-las-estructuras-if",
    "title": "8  If, Else y Elif",
    "section": "8.6 ¿Cómo se anidan las estructuras IF?",
    "text": "8.6 ¿Cómo se anidan las estructuras IF?\nLos IF anidados permiten evaluar condiciones dentro de otras condiciones. Esto es útil para verificar múltiples niveles de requisitos.\n\nisMember = True\nage = 15\n\n# Si es miembro\nif isMember:\n    # Si es miembro y es mayor a 15 anios\n    if age &gt;= 15:\n        print(\"Tienes acceso ya que eres miembro y mayor que 15\")\n\n    # Si es miembro, pero es menor a 15 anios\n    else:\n        print(\"No tienes acceso ya que eres miembro, pero menor a 15 años\")\n\n# Si no es miembro\nelse:\n    print(\"No eres miembro y no tienes acceso\")\n\nTienes acceso ya que eres miembro y mayor que 15",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>If, Else y Elif</span>"
    ]
  },
  {
    "objectID": "qmd/python/bucles.html",
    "href": "qmd/python/bucles.html",
    "title": "9  Iteraciones y bucles",
    "section": "",
    "text": "9.1 For\nAprender a automatizar el proceso de iteración en listas utilizando bucles y controles de iteración es fundamental para optimizar el manejo de datos en Python.\nUn bucle for en Python te permite recorrer secuencias (listas, tuplas, cadenas, rangos, etc.) elemento a elemento, ejecutando un bloque de código para cada uno. Su sintaxis básica es:\nfor elemento in iterable:\n    # bloque de código que usa “elemento”\nSus características son:\nEjemplo con una lista\n# Lista\nnumbers = [1, 2, 3, 4, 5, 6]\n\n# Imprimir el valor de i\nfor i in numbers:\n    print(f\"El valor de i es: {i}\")\n\nEl valor de i es: 1\nEl valor de i es: 2\nEl valor de i es: 3\nEl valor de i es: 4\nEl valor de i es: 5\nEl valor de i es: 6",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Iteraciones y bucles</span>"
    ]
  },
  {
    "objectID": "qmd/python/bucles.html#for",
    "href": "qmd/python/bucles.html#for",
    "title": "9  Iteraciones y bucles",
    "section": "",
    "text": "Iterable: cualquier objeto que implemente el protocolo de iteración (list, tuple, str, dict, range, etc.).\nElemento: variable que toma, en cada iteración, el siguiente valor del iterable.\nEl bloque indentado se ejecuta una vez por cada elemento.",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Iteraciones y bucles</span>"
    ]
  },
  {
    "objectID": "qmd/python/bucles.html#range",
    "href": "qmd/python/bucles.html#range",
    "title": "9  Iteraciones y bucles",
    "section": "9.2 Range",
    "text": "9.2 Range\nELa función range permite iterar un conjunto de números fijos para producir índices o repeticiones controladas.\n\n\n\n\n\n\nNote\n\n\n\nEs importante mencionar que range omite el último número solicitado.\n\n\nEjemplos:\n\n# Imprimit del 0 al 9, omitiendo el 10\nfor i in range(10):\n    print(i)\n\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# Imprime del 3 al 9\nfor i in range(3, 10):\n    print(i)  \n\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# range(start, stop, step)\n# Imprime los pares entre 2 y 10 (excluyendo 10)\nfor n in range(2, 10, 2):\n    print(n)\n\n2\n4\n6\n8",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Iteraciones y bucles</span>"
    ]
  },
  {
    "objectID": "qmd/python/bucles.html#condicionales-dentro-de-bucles",
    "href": "qmd/python/bucles.html#condicionales-dentro-de-bucles",
    "title": "9  Iteraciones y bucles",
    "section": "9.3 Condicionales dentro de bucles",
    "text": "9.3 Condicionales dentro de bucles\nTambién podemos utilizar condicionales ìf, else y elif al momento de usar los bucles for.\nUn ejemplo sencillo sería:\n\nfrutas = [\"manzana\", \"pera\", \"uva\", \"naranja\", \"tomate\"]\nfor fruta in frutas:\n    print(fruta)\n    if fruta == \"naranja\":\n        print(\"naranja encontrada\")\n\nmanzana\npera\nuva\nnaranja\nnaranja encontrada\ntomate\n\n\nEn tanto, un ejemplo más complejo sería:\n\nEl for itera i desde 0 hasta 9.\nif i % 2 == 0 comprueba si es par.\nSi no es par, elif i % 3 == 0 comprueba si es múltiplo de 3.\nelse cubre todos los demás casos.\n\n\n# Recorremos del 0 al 9\nfor i in range(10):\n    if i % 2 == 0:\n        print(f\"{i} es par\")\n    elif i % 3 == 0:\n        print(f\"{i} es múltiplo de 3 pero no par\")\n    else:\n        print(f\"{i} es impar y no múltiplo de 3\")\n\n0 es par\n1 es impar y no múltiplo de 3\n2 es par\n3 es múltiplo de 3 pero no par\n4 es par\n5 es impar y no múltiplo de 3\n6 es par\n7 es impar y no múltiplo de 3\n8 es par\n9 es múltiplo de 3 pero no par",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Iteraciones y bucles</span>"
    ]
  },
  {
    "objectID": "qmd/python/bucles.html#while",
    "href": "qmd/python/bucles.html#while",
    "title": "9  Iteraciones y bucles",
    "section": "9.4 while",
    "text": "9.4 while\nLa instrucción while permite ejecutar un bloque de código de forma repetida mientras una condición booleana sea True. Es útil cuando no sabemos de antemano cuántas iteraciones haremos.\nEn este ejemplo estamos diciendo “voy a imprimir el contar cuando sea menor a 5”\n\n# Ejemplo: contar de 0 a 4\ncontador = 0\nwhile contador &lt; 5:\n    print(f\"Valor de contador: {contador}\")\n    contador += 1\n\nValor de contador: 0\nValor de contador: 1\nValor de contador: 2\nValor de contador: 3\nValor de contador: 4",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Iteraciones y bucles</span>"
    ]
  },
  {
    "objectID": "qmd/python/bucles.html#break-y-continue",
    "href": "qmd/python/bucles.html#break-y-continue",
    "title": "9  Iteraciones y bucles",
    "section": "9.5 break y continue",
    "text": "9.5 break y continue\nLa palabra clave break se utiliza para salir del bucle prematuramente, mientras que continue omite la iteración actual y pasa a la siguiente:\n\nfor i in numbers:\n    if i == 3:\n        break\n    print(i)  # Termina al llegar a 3\n\n1\n2\n\n\n\nfor i in numbers:\n    if i == 3:\n        continue\n    print(i)  # Omite el 3\n\n1\n2\n4\n5\n6",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Iteraciones y bucles</span>"
    ]
  },
  {
    "objectID": "qmd/python/iteradores.html",
    "href": "qmd/python/iteradores.html",
    "title": "10  Iteradores y generadores",
    "section": "",
    "text": "10.1 ¿Qué es un generador y cómo se utiliza?\nTrabajar con iteradores y generadores en Python permite manejar grandes cantidades de datos de manera eficiente, sin necesidad de cargar todo en memoria.\nUn iterador es un objeto que produce una secuencia de valores uno a uno, bajo demanda, implementando dos métodos clave:\nTodos los iteradores son iterables, pero no todos los iterables son iteradores hasta que se les aplica iter().\nEjemplo:\nLos iteradores también pueden recorrer cadenas de texto.\nUn generador en Python es una función que, en lugar de devolver todos sus resultados de golpe con return, utiliza la palabra clave yield para ir “produciendo” valores uno a uno y de forma perezosa (lazy), es decir, solo cuando el código que lo consume los solicita.\ndef mi_generador():\n    yield 1\n    yield 2\n    yield 3\n\n# Usar el generador\nfor valor in mi_generador():\n    print(valor)\n\n1\n2\n3\nEjemplo con serie Fibonacci\ndef fibonacci(limite):\n    a, b = 0, 1\n    while a &lt; limite:\n        yield a\n        a, b = b, a + b\n\n# Usar el generador para la serie de Fibonacci hasta 10\nfor numero in fibonacci(10):\n    print(numero)\n\n0\n1\n1\n2\n3\n5\n8",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Iteradores y generadores</span>"
    ]
  },
  {
    "objectID": "qmd/python/comprehension_list.html",
    "href": "qmd/python/comprehension_list.html",
    "title": "11  Comprehension List",
    "section": "",
    "text": "Una Comprehension List es una forma concisa de crear listas en Python, pues permite generar listas nuevas transformando cada elemento de una colección existente o creando elementos a partir de un rango. La sintaxis es compacta y directa, lo que facilita la comprensión del propósito de tu código de un vistazo.\n\n\n\n\n\n\nEstructura básica de una Comprehension List:\n\n\n\n[expresión for elemento in iterable if condición]\nQue se traduce a: “Crea una nueva lista evaluando nueva_expresión para cada elemento en el iterable.”\n\n\nEjemplos:\n\nDoble de los Números\n\nDada una lista de números [1, 2, 3, 4, 5], crea una nueva lista que contenga el doble de cada número usando una List Comprehension.\n\nnumbers = [1, 2, 3, 4, 5]\nsquares = [x ** 2 for x in numbers]\nprint(f\"Cuadrados: {squares}\")\n\nCuadrados: [1, 4, 9, 16, 25]\n\n\n\nFiltrar y Transformar en un Solo Paso\n\nTienes una lista de palabras [“sol”, “mar”, “montaña”, “rio”, “estrella”] y quieres obtener una nueva lista con las palabras que tengan más de 3 letras y estén en mayúsculas.\n\npalabras = [\"sol\", \"mar\", \"montaña\", \"rio\", \"estrella\"]\npalabras_mod = [x.upper() for x in palabras if len(x) &gt; 3]\nprint(f\"Las palabras moficadas son: {palabras_mod}\")\n\nLas palabras moficadas son: ['MONTAÑA', 'ESTRELLA']\n\n\n\nAnidación de List Comprehensions\n\nDada una lista de listas (una matriz), calcula la matriz traspuesta utilizando una List Comprehension anidada.\n\nmatriz = [\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9]\n]\ntranspuesta_comprehension = [[fila[i] for fila in matriz] for i in range(len(matriz[0]))]\nprint(\"Transpuesta con List Comprehension:\", transpuesta_comprehension)\n\nTranspuesta con List Comprehension: [[1, 4, 7], [2, 5, 8], [3, 6, 9]]",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Comprehension List</span>"
    ]
  },
  {
    "objectID": "qmd/python/funciones.html",
    "href": "qmd/python/funciones.html",
    "title": "12  Funciones y parámetros",
    "section": "",
    "text": "12.1 Parámetros o argumentos de una función\nEn Python, uno de los principios fundamentales es el de divide y vencerás. Esto se refiere a dividir el código en porciones más pequeñas para facilitar su legibilidad, mantenimiento y reutilización.\nLas funciones nos permiten encapsular lógica específica, evitando la duplicación de código.\nUn parámetro es una variable que se define en la declaración de una función y sirve como un marcador de posición para los valores que la función recibirá.\nPodemos tener múltiples parámetros dentro de una misma función, donde cada uno se reemplaza en algún lugar del cuerpo de la función.\nIncluso, se pueden definir parámetros por defecto, que se utilizarán si no se proporciona uno específico.\ndef saludar(name, last_name = \"Casas\"):\n    print(f\"Hola, {name} {last_name}\")\n\nsaludar(name = \"Armando\")\n\nHola, Armando Casas",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Funciones y parámetros</span>"
    ]
  },
  {
    "objectID": "qmd/python/funciones_lambda.html",
    "href": "qmd/python/funciones_lambda.html",
    "title": "13  Funciones lambda",
    "section": "",
    "text": "13.1 map()\nEn el capítulo anterior, revisamos la difinición de funciones explícitas en python.\nHabrán momentos en donde querramos usar funciones pequeñas, que no necesitemos reutilizar constamente, es decir, que solo usemos en una línea en específico. En estos casos, es recomedable construir una función lambda.\nComo usuario de R, mi vida mejoró cuando aprendí a utilizar purrr::map() y sus otro útiles derivados. Por suerte map() también está en python, cumpliendo con la misma funcionalidad: aplicar una función a todos los elementos.\n# Python\nnumbers = range(11)\nlist(map(lambda x: x**2, numbers))\n\n# Esto es similar a lo que hariamos en R\n# numbers &lt;- list(1:10)\n# purrr::map(numbers, \\(x) x**2)\n# [1]   1   4   9  16  25  36  49  64  81 100\n\n[0, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\nAquí, map() aplica la función lambda a cada elemento de la lista numbers, devolviendo una nueva lista con los resultados.",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Funciones lambda</span>"
    ]
  },
  {
    "objectID": "qmd/python/funciones_lambda.html#filter",
    "href": "qmd/python/funciones_lambda.html#filter",
    "title": "13  Funciones lambda",
    "section": "13.2 filter()",
    "text": "13.2 filter()\nfilter() filtra los elementos de una secuencia según una función que devuelve True o False.\nEn este ejemplo, filter() utiliza la función lambda para seleccionar solo los números pares de la lista.\n\nlist(filter(lambda x: x % 2 == 0, numbers))\n\n[0, 2, 4, 6, 8, 10]",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Funciones lambda</span>"
    ]
  },
  {
    "objectID": "qmd/python/recursividad.html",
    "href": "qmd/python/recursividad.html",
    "title": "14  Recursividad",
    "section": "",
    "text": "14.1 Consideraciones sobre la Recursividad\nLa recursividad es una técnica de programación en la que una función se llama a sí misma para resolver un problema. Un problema se divide en subproblemas más pequeños y la función se llama recursivamente hasta que se alcanza una condición base que finaliza las llamadas recursivas.\nCuando llamas a una función en Python (o en la mayoría de los lenguajes de programación), la llamada a la función se añade al call stack. El call stack lleva un registro de todas las llamadas a funciones que necesitan resolverse. Cuando una función devuelve un valor, se elimina del call stack.\nPara el caso del factorial de 5 tendríamos algo así:\nCuando se llama a factorial(0), se alcanza el caso base y devuelve 1. Este valor de retorno comienza el proceso de desenrollar el call stack.\nEjemplo de función factorial(5):",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Recursividad</span>"
    ]
  },
  {
    "objectID": "qmd/python/recursividad.html#consideraciones-sobre-la-recursividad",
    "href": "qmd/python/recursividad.html#consideraciones-sobre-la-recursividad",
    "title": "14  Recursividad",
    "section": "",
    "text": "Condición Base: Es crucial definir correctamente una condición base para evitar llamadas recursivas infinitas.\nEficiencia: Las implementaciones recursivas pueden ser ineficientes para problemas complejos debido a la sobrecarga de llamadas a funciones.\nPython tiene un límite de recursión (por defecto ~1000 llamadas) para evitar desbordamiento de pila. Para problemas grandes, considera alternativas iterativas.",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Recursividad</span>"
    ]
  },
  {
    "objectID": "qmd/python/errores.html",
    "href": "qmd/python/errores.html",
    "title": "15  Manejo de errores",
    "section": "",
    "text": "15.1 try:\nLas excepciones (o errores) en Python están organizadas en una jerarquía de clases, donde las excepciones más generales se encuentran en la parte superior y las más específicas en la parte inferior.\nLo normal es que cuando ocurre un error, el código se rompe, finaliza su ejecución, no dejando avanzar en las siguientes líneas. Aquí es donde entramos nosotros, pues debemos aprender a manejar esos errores, ya sea para enviar un mensaje de qué está ocurriendo o realizando alguna otra tarea cuando ocurre un error.\nEl bloque try: en Python es una estructura de control que te permite intentar ejecutar código que podría generar una excepción (error) y manejar esa situación de forma controlada, evitando que el programa se detenga abruptamente.\nUna buena práctica es manejar el TipoDeError si lo conocemos con anterioridad. En el siguiente ejemplo podemos ver cómo se definen los errores dependiendo del valor que toma numero.\n# Lo ideal seria que el ejemplo sea con un input(), pero eso no es \n# admisible usando quarto, asi que definire un valor X para el \n# ejemplo, de todas maneras quedo comentado.\n\nnumero = 0\n\ntry:\n    # numero = int(input(\"Ingresa un número: \"))\n    resultado = 10 / numero\n    print(f\"El resultado es: {resultado}\")\nexcept ValueError:\n    print(\"Error: No ingresaste un número válido\")\nexcept ZeroDivisionError:\n    print(\"Error: No puedes dividir por cero\")\nexcept Exception as e:\n    print(f\"Error inesperado: {e}\")\nelse:\n    print(\"Todo salió bien, no hubo errores\")\nfinally:\n    print(\"Operación finalizada\")\n\nError: No puedes dividir por cero\nOperación finalizada\nLa lógica del código es:",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Manejo de errores</span>"
    ]
  },
  {
    "objectID": "qmd/python/errores.html#try",
    "href": "qmd/python/errores.html#try",
    "title": "15  Manejo de errores",
    "section": "",
    "text": "Estructúra básica de un try: except:\n\n\n\n\ntry:\n    # Código que puede generar una excepción\n    codigo_riesgoso()\nexcept TipoDeError:\n    # Código que se ejecuta si ocurre ese error específico\n    print(\"Se produjo un error\")\nfinally:\n    # Código que SIEMPRE se ejecuta (opcional)\n    print(\"Limpieza final\")\n\n\n\n\n\n\n\ntry: Python ejecuta el código dentro del bloque try\nSi no hay error: continúa con el bloque else (si existe) y luego finally\nSi hay error: busca un bloque except que coincida con el tipo de excepción\nexcept: maneja el error específico\nfinally: se ejecuta siempre, haya error o no (útil para cerrar archivos, conexiones, etc.)",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Manejo de errores</span>"
    ]
  },
  {
    "objectID": "qmd/python/errores.html#levantar-errores-personalizados",
    "href": "qmd/python/errores.html#levantar-errores-personalizados",
    "title": "15  Manejo de errores",
    "section": "15.2 Levantar errores personalizados",
    "text": "15.2 Levantar errores personalizados\nEn ciertas ocasiones necesitarás errores personalizados para tu programa. Para levantar una excepción o error puedes utilizar raise y seguido de la clase del error con un mensaje personalizado.\nLevantar excepciones hace que nuestro código más explicativo de lo que debemos o no manejar.\nPor ejemplo, creemos una función que evalúe la edad de un usuario no sea negativa y que no sea menor de edad.\n\ndef verificar_edad(edad):\n    if edad &lt; 0:\n        raise ValueError(\"La edad no puede ser negativa\")\n    elif edad &lt; 18:\n        raise Exception(\"La persona es menor de edad\")\n    else:\n        return \"Edad válida\"\n\nprint(f\"Primer error personalizado: {verificar_edad(-20)}\")\n# ValueError: La edad no puede ser negativa\n\nprint(f\"Segundo error personalizado: {verificar_edad(15)}\")\n# Exception: La persona es menor de edad",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Manejo de errores</span>"
    ]
  },
  {
    "objectID": "qmd/python/errores.html#jerarquías-de-excepciones",
    "href": "qmd/python/errores.html#jerarquías-de-excepciones",
    "title": "15  Manejo de errores",
    "section": "15.3 Jerarquías de excepciones",
    "text": "15.3 Jerarquías de excepciones\nLas excepciones tienen jerarquías, esto significa que están organizadas en una estructura de clases tipo árbol, donde unas excepciones son más generales (padre) y otras más específicas (hijas), heredando características de sus clases padre.\nEsta jerarquía es importante porque podemos tratar a una exepción padre y que englobará a todas las excepciones hijas.\nLa clase base de todas las excepciones es BaseException, y de ahí se derivan clases más específicas:\n\ndef print_exception_hierarchy(exception_class, indent=0):\n    print(' ' * indent + exception_class.__name__)\n    for subclass in exception_class.__subclasses__():\n        print_exception_hierarchy(subclass, indent + 4)\n\n# Imprimir la jerarquía comenzando desde la clase base Exception\nprint_exception_hierarchy(Exception)\n\nException\n    ArithmeticError\n        FloatingPointError\n        OverflowError\n        ZeroDivisionError\n            DivisionByZero\n            DivisionUndefined\n        DecimalException\n            Clamped\n            Rounded\n                Underflow\n                Overflow\n            Inexact\n                Underflow\n                Overflow\n            Subnormal\n                Underflow\n            DivisionByZero\n            FloatOperation\n            InvalidOperation\n                ConversionSyntax\n                DivisionImpossible\n                DivisionUndefined\n                InvalidContext\n    AssertionError\n    AttributeError\n        FrozenInstanceError\n    BufferError\n    EOFError\n        IncompleteReadError\n    ImportError\n        ModuleNotFoundError\n            PackageNotFoundError\n        ZipImportError\n    LookupError\n        IndexError\n            IllegalMonthError\n        KeyError\n            NoSuchKernel\n            UnknownBackend\n        CodecRegistryError\n    MemoryError\n    NameError\n        UnboundLocalError\n    OSError\n        BlockingIOError\n        ChildProcessError\n        ConnectionError\n            BrokenPipeError\n            ConnectionAbortedError\n            ConnectionRefusedError\n            ConnectionResetError\n                RemoteDisconnected\n        FileExistsError\n        FileNotFoundError\n        InterruptedError\n            InterruptedSystemCall\n        IsADirectoryError\n        NotADirectoryError\n        PermissionError\n        ProcessLookupError\n        TimeoutError\n        UnsupportedOperation\n        itimer_error\n        herror\n        gaierror\n        SSLError\n            SSLCertVerificationError\n            SSLZeroReturnError\n            SSLWantWriteError\n            SSLWantReadError\n            SSLSyscallError\n            SSLEOFError\n        Error\n            SameFileError\n        SpecialFileError\n        ExecError\n        ReadError\n        URLError\n            HTTPError\n            ContentTooShortError\n        BadGzipFile\n    ReferenceError\n    RuntimeError\n        NotImplementedError\n            UnsupportedOperation\n            ZMQVersionError\n            StdinNotImplementedError\n        PythonFinalizationError\n        RecursionError\n        _DeadlockError\n        BrokenBarrierError\n        BrokenExecutor\n            BrokenThreadPool\n        SendfileNotAvailableError\n        BrokenBarrierError\n        VariableError\n    StopAsyncIteration\n    StopIteration\n    SyntaxError\n        IndentationError\n            TabError\n        _IncompleteInputError\n    SystemError\n        CodecRegistryError\n    TypeError\n        FloatOperation\n        MultipartConversionError\n    ValueError\n        UnicodeError\n            UnicodeDecodeError\n            UnicodeEncodeError\n            UnicodeTranslateError\n        NotShareableError\n        UnsupportedOperation\n        JSONDecodeError\n        SSLCertVerificationError\n        Error\n        UnsupportedDigestmodError\n        AddressValueError\n        NetmaskValueError\n        IllegalMonthError\n        IllegalWeekdayError\n        ParserError\n        ClassNotFound\n        MessageDefect\n            NoBoundaryInMultipartDefect\n            StartBoundaryNotFoundDefect\n            CloseBoundaryNotFoundDefect\n            FirstHeaderLineIsContinuationDefect\n            MisplacedEnvelopeHeaderDefect\n            MissingHeaderBodySeparatorDefect\n            MultipartInvariantViolationDefect\n            InvalidMultipartContentTransferEncodingDefect\n            UndecodableBytesDefect\n            InvalidBase64PaddingDefect\n            InvalidBase64CharactersDefect\n            InvalidBase64LengthDefect\n            HeaderDefect\n                InvalidHeaderDefect\n                HeaderMissingRequiredValue\n                NonPrintableDefect\n                ObsoleteHeaderDefect\n                NonASCIILocalPartDefect\n                InvalidDateDefect\n        ClipboardEmpty\n        MacroToEdit\n        InvalidVersion\n        InvalidFileException\n    Warning\n        BytesWarning\n        DeprecationWarning\n            ProvisionalWarning\n        EncodingWarning\n        FutureWarning\n            ProvisionalCompleterWarning\n        ImportWarning\n        PendingDeprecationWarning\n        ResourceWarning\n        RuntimeWarning\n            ProactorSelectorThreadWarning\n            UnknownTimezoneWarning\n        SyntaxWarning\n        UnicodeWarning\n        UserWarning\n            GetPassWarning\n            FormatterWarning\n        DeprecatedTzFormatWarning\n    InterpreterError\n        InterpreterNotFoundError\n    ExceptionGroup\n    PatternError\n    _Error\n    _OptionError\n    Error\n    SubprocessError\n        CalledProcessError\n        TimeoutExpired\n    ZMQBaseError\n        ZMQError\n            ContextTerminated\n            Again\n            InterruptedSystemCall\n        ZMQBindError\n        NotDone\n    error\n    PickleError\n        PicklingError\n        UnpicklingError\n    _Stop\n    Error\n        CancelledError\n        InvalidStateError\n    _GiveupOnSendfile\n    Incomplete\n    TokenError\n    ClassFoundException\n    EndOfBlock\n    InvalidStateError\n    LimitOverrunError\n    QueueEmpty\n    QueueFull\n    QueueShutDown\n    TraitError\n    Error\n    Empty\n    Full\n    ShutDown\n    error\n    error\n    ReturnValueIgnoredError\n    ArgumentError\n    ArgumentTypeError\n    ConfigError\n        ConfigLoaderError\n            ArgumentError\n        ConfigFileNotFound\n    ConfigurableError\n        MultipleInstanceError\n    ApplicationError\n    InvalidPortNumber\n    error\n    LZMAError\n    RegistryError\n    _GiveupOnFastCopy\n    NoIPAddresses\n    BadZipFile\n    LargeZipFile\n    TraversalError\n    DuplicateKernelError\n    NotOneValueFound\n    KnownIssue\n    VerifierFailure\n    CannotEval\n    OptionError\n    FindCmdError\n    HomeDirError\n    ErrorDuringImport\n    BdbQuit\n    Restart\n    ProfileDirError\n    IPythonCoreError\n        TryNext\n        UsageError\n        StdinNotImplementedError\n    InputRejected\n    GetoptError\n    ErrorToken\n    PrefilterError\n    AliasError\n        InvalidAliasError\n    Error\n        InterfaceError\n        DatabaseError\n            InternalError\n            OperationalError\n            ProgrammingError\n            IntegrityError\n            DataError\n            NotSupportedError\n    Warning\n    SpaceInInput\n    DOMException\n        IndexSizeErr\n        DomstringSizeErr\n        HierarchyRequestErr\n        WrongDocumentErr\n        InvalidCharacterErr\n        NoDataAllowedErr\n        NoModificationAllowedErr\n        NotFoundErr\n        NotSupportedErr\n        InuseAttributeErr\n        InvalidStateErr\n        SyntaxErr\n        InvalidModificationErr\n        NamespaceErr\n        InvalidAccessErr\n        ValidationErr\n    ValidationError\n    EditReadOnlyBuffer\n    _Retry\n    InvalidLayoutError\n    HeightIsUnknownError\n    ExpatError\n    ParseEscape\n    MessageError\n        MessageParseError\n            HeaderParseError\n            BoundaryError\n        MultipartConversionError\n        CharsetError\n        HeaderWriteError\n    GuardRejection\n    ParserSyntaxError\n    InternalParseError\n    _PositionUpdatingFinished\n    SimpleGetItemNotFound\n    UncaughtAttributeError\n    HasNoContext\n    ParamIssue\n    _JediError\n        InternalError\n        WrongVersion\n        RefactoringError\n    OnErrorLeaf\n    InvalidPythonEnvironment\n    HTTPException\n        NotConnected\n        InvalidURL\n        UnknownProtocol\n        UnknownTransferEncoding\n        UnimplementedFileMode\n        IncompleteRead\n        ImproperConnectionState\n            CannotSendRequest\n            CannotSendHeader\n            ResponseNotReady\n        BadStatusLine\n            RemoteDisconnected\n        LineTooLong\n    InteractivelyDefined\n    RaiseAfterInterrupt\n    KillEmbedded\n    Error\n        NoSuchProcess\n            ZombieProcess\n        AccessDenied\n        TimeoutExpired\n    KeyReuseError\n    UnknownKeyError\n    LeakedCallbackError\n    BadYieldError\n    ReturnValueIgnoredError\n    Return\n    QueueEmpty\n    QueueFull\n    ArgumentError\n    DebuggerInitializationError\n    Error\n        ProtocolError\n        ResponseError\n        Fault\n    _Error\n    UnableToResolveVariableException\n    InvalidTypeInArgsException",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Manejo de errores</span>"
    ]
  },
  {
    "objectID": "qmd/python/poo1_clases.html",
    "href": "qmd/python/poo1_clases.html",
    "title": "16  POO 1: clases",
    "section": "",
    "text": "16.1 Crear una clase\nLa Programación Orientada a Objetos es un paradigma de programación que organiza el diseño del software en torno a objetos. Los objetos son instancias de clases, que pueden tener atributos (datos) y métodos (funciones).\nLas clases actúan como plantillas genéricas que definen atributos y comportamientos. Por ejemplo, una clase “Persona” puede tener atributos como nombre, apellido y fecha de nacimiento.\nConceptos claves:\nPara crear una clase en Python, se utiliza la palabra reservada class seguida del nombre de la clase con la primera letra en mayúscula (es una buena práctica). Dentro de la clase, se define un constructor con la función __init__. Esta función inicializa los atributos del objeto.\n# Difinicion de la clase\nclass Persona:\n    # Constructor de la clase:\n    #   - Es importante que tenga 'self'\n    def __init__(self, nombre, edad):\n        self.nombre = nombre\n        self.edad = edad\n    \n    def saludar(self):\n        print(f\"Hola, mi nombre es {self.nombre} y tengo {self.edad} años\")\nCrearemos dos objetos utilzando esta clase:\n# Crear objetos de la clase Persona\npersona1 = Persona(nombre = \"Ana\", edad = 30)\npersona2 = Persona(\"Luis\", 25)\nY utilizamos el método saludar de nuestra clase Persona: los métodos son funciones definidas dentro de una clase que operan sobre los objetos de la misma.\npersona1.saludar()\npersona2.saludar()\n\nHola, mi nombre es Ana y tengo 30 años\nHola, mi nombre es Luis y tengo 25 años",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>POO 1: clases</span>"
    ]
  },
  {
    "objectID": "qmd/python/poo1_clases.html#self---analogía-con-un-espejo",
    "href": "qmd/python/poo1_clases.html#self---analogía-con-un-espejo",
    "title": "16  POO 1: clases",
    "section": "16.2 Self - Analogía con un espejo:",
    "text": "16.2 Self - Analogía con un espejo:\nEncotré este ejemplo en un comentario el platzi.\nImagina que cada objeto tiene un espejo. Cuando un objeto se mira en el espejo (self), ve sus propios atributos (nombre, color, nivel de batería) y puede actuar sobre ellos (caminar, hablar, cargar batería).\nEjemplo con robot’s:\n\nclass Robot:\n    def __init__(self, nombre, color, nivel_bateria):\n        self.nombre = nombre\n        self.color = color\n        self.nivel_bateria = nivel_bateria\n\n    def caminar(self):\n        if self.nivel_bateria &gt; 10:\n            print(f\"{self.nombre} está caminando.\")\n            self.nivel_bateria -= 10  # Reduce la batería al caminar\n        else:\n            print(f\"{self.nombre} necesita recargar batería.\")\n\n    def hablar(self, mensaje):\n        print(f\"{self.nombre} dice: {mensaje}\")\n\n    def cargar_bateria(self):\n        self.nivel_bateria = 100\n        print(f\"{self.nombre} ha recargado su batería al 100%.\")\n\n# Creamos dos robots\nmi_robot = Robot(\"R2-D2\", \"blanco\", 100)\n\n# Hacemos que los robots realicen acciones\nmi_robot.caminar()        # Output: R2-D2 está caminando.\nmi_robot.hablar(\"¡Hola!\")  # Output: R2-D2 dice: ¡Hola!\n\n# Simulamos que los robots caminan varias veces\nfor _ in range(10): \n    mi_robot.caminar()\n\nmi_robot.caminar()        # Output: R2-D2 necesita recargar batería.\nmi_robot.cargar_bateria()  # Output: R2-D2 ha recargado su batería al 100%.\nmi_robot.caminar()        # Output: R2-D2 está caminando.",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>POO 1: clases</span>"
    ]
  },
  {
    "objectID": "qmd/python/poo2_herencias.html",
    "href": "qmd/python/poo2_herencias.html",
    "title": "17  POO 2: herencias",
    "section": "",
    "text": "17.1 Ejemplo: sistema de vehículos\nImagina que tienes un coche y una bicicleta. Ambos son vehículos. Aunque son diferentes, tienen cosas en común: ambos pueden moverse, tienen ruedas, y se pueden usar para transportarte. La Herencia es como decir:\nEn términos simples, la Herencia permite que una clase (la “clase hija”) tome características y comportamientos de otra clase (la “clase padre”).\n¿Por qué es útil la Herencia?\n# Clase padre (superclase)\nclass Vehiculo:\n    def __init__(self, marca, modelo, año):\n        self.marca = marca\n        self.modelo = modelo\n        self.año = año\n        self.encendido = False\n\n    # Métodos comunes en Vehiculo\n    def encender(self):\n        self.encendido = True\n        print(f\"{self.marca} {self.modelo} está encendido\")\n    \n    def apagar(self):\n        self.encendido = False\n        print(f\"{self.marca} {self.modelo} está apagado\")\n    \n    def info(self):\n        return f\"{self.marca} {self.modelo} ({self.año})\"\n# Clase hija que hereda de Vehiculo\nclass Auto(Vehiculo):\n    def __init__(self, marca, modelo, año, puertas):\n        super().__init__(marca, modelo, año)  # Llama al constructor del padre\n        self.puertas = puertas\n    \n    def abrir_cajuela(self):\n        print(f\"Cajuela del {self.marca} {self.modelo} abierta\")\n    \n    # Sobrescribir método del padre (polimorfismo)\n    def info(self):\n        return f\"{super().info()} - {self.puertas} puertas\"\n\n# Otra clase hija\nclass Motocicleta(Vehiculo):\n    def __init__(self, marca, modelo, año, cilindrada):\n        super().__init__(marca, modelo, año)\n        self.cilindrada = cilindrada\n    \n    def hacer_wheelie(self):\n        if self.encendido:\n            print(f\"¡{self.marca} {self.modelo} haciendo wheelie!\")\n        else:\n            print(\"Primero enciende la motocicleta\")\n    \n    def info(self):\n        return f\"{super().info()} - {self.cilindrada}cc\"\nUso de las clases:\n# Crear instancias\nmi_auto = Auto(\"Toyota\", \"Corolla\", 2022, 4)\nCuando se ejecuta ocurre:\nmi_moto = Motocicleta(\"Honda\", \"CBR\", 2021, 600)\n\n# Usar métodos heredados\nmi_auto.encender()          # Método del padre\nmi_moto.encender()          # Método del padre\n\n# Usar métodos específicos de cada clase\nmi_auto.abrir_cajuela()     # Método específico de Auto\nmi_moto.hacer_wheelie()     # Método específico de Motocicleta\n\n# Polimorfismo: mismo método, comportamiento diferente\nprint(mi_auto.info())       # Toyota Corolla (2022) - 4 puertas\nprint(mi_moto.info())       # Honda CBR (2021) - 600cc\n\nToyota Corolla está encendido\nHonda CBR está encendido\nCajuela del Toyota Corolla abierta\n¡Honda CBR haciendo wheelie!\nToyota Corolla (2022) - 4 puertas\nHonda CBR (2021) - 600cc",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>POO 2: herencias</span>"
    ]
  },
  {
    "objectID": "qmd/python/poo2_herencias.html#ejemplo-sistema-de-vehículos",
    "href": "qmd/python/poo2_herencias.html#ejemplo-sistema-de-vehículos",
    "title": "17  POO 2: herencias",
    "section": "",
    "text": "Es la clase base que define características comunes a todos los vehículos.\n__init__ es el constructor que inicializa los atributos básicos.\nTodos los vehículos tienen marca, modelo, año y estado de encendido.\n\n\n\nAuto(Vehiculo) significa que Auto hereda de Vehiculo.\nsuper().__init__() ejecuta el constructor del padre primero.\nLuego agregamos puertas, que es específico de los autos.\n\n\n\n\n\n\nSe llama Auto.__init__().\nQue a su vez llama Vehiculo.__init__() con super().\nSe inicializan marca, modelo, año, encendido (del padre).\nSe inicializa puertas (específico del auto).",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>POO 2: herencias</span>"
    ]
  },
  {
    "objectID": "qmd/python/poo3_resumen.html",
    "href": "qmd/python/poo3_resumen.html",
    "title": "18  POO: resumen",
    "section": "",
    "text": "18.1 Uso de super() en Python\nPara entender mejor la Programación Orientada a Objetos (POO), es esencial recordar los conceptos básicos de atributos y métodos.\nEjemplo Básico de una Clase:\nAl usar herencia vimos el método init() que es el cosntructor, el mismo es llamado automáticamente cuando se crea una nueva instancia de una clase y se utiliza para inicializar los atributos del objeto.\nEn este ejemplo, el constructor __init__ inicializa los atributos name y age de la clase Person.\nLa función super() en Python te permite acceder y llamar a métodos definidos en la superclase desde una subclase. Esto es útil cuando quieres extender o modificar la funcionalidad de los métodos de la superclase sin tener que repetir su implementación completa.\nEjemplo de Uso de super():\nclass Person:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n\n    def greet(self):\n        print(\"Hello! I am a person.\")\n\nclass Student(Person):\n    def __init__(self, name, age, student_id):\n        super().__init__(name, age)\n        self.student_id = student_id\n\n    def greet(self):\n        super().greet()\n        print(f\"Hi, I'm {self.name}, and I'm a student with ID: {self.student_id}\")\n\n# Crear instancia de Student y llamar a greet\nstudent = Student(\"Ana\", 20, \"S12345\")\nstudent.greet()  \n# Output: Hello! I am a person.\n#         Hi, I'm Ana, and I'm a student with ID: S12345\nEn este ejemplo:",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>POO: resumen</span>"
    ]
  },
  {
    "objectID": "qmd/python/poo3_resumen.html#uso-de-super-en-python",
    "href": "qmd/python/poo3_resumen.html#uso-de-super-en-python",
    "title": "18  POO: resumen",
    "section": "",
    "text": "La clase Person define un método greet() que imprime un saludo genérico.\nLa clase Student, que es una subclase de Person, utiliza super().__init__(name, age) para llamar al constructor de la superclase Person y luego sobrescribe el método greet() para agregar información específica del estudiante.",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>POO: resumen</span>"
    ]
  },
  {
    "objectID": "qmd/python/poo3_resumen.html#jerarquía-de-clases-y-constructores",
    "href": "qmd/python/poo3_resumen.html#jerarquía-de-clases-y-constructores",
    "title": "18  POO: resumen",
    "section": "18.2 Jerarquía de Clases y Constructores",
    "text": "18.2 Jerarquía de Clases y Constructores\n¿Qué sucede si una clase tiene una clase padre y esa clase padre tiene otra clase padre? En este caso, usamos super() para asegurar que todas las clases padre sean inicializadas correctamente.\nEjemplo de Jerarquía de Clases:\n\nclass LivingBeing:\n    def __init__(self, name):\n        self.name = name\n\nclass Person(LivingBeing):\n    def __init__(self, name, age):\n        super().__init__(name)\n        self.age = age\n\nclass Student(Person):\n    def __init__(self, name, age, student_id):\n        super().__init__(name, age)\n        self.student_id = student_id\n\n    def introduce(self):\n        print(f\"Hi, I'm {self.name}, {self.age} years old, and my student ID is {self.student_id}\")\n\n# Crear instancia de Student\nstudent = Student(\"Carlos\", 21, \"S54321\")\nstudent.introduce()  \n# Output: Hi, I'm Carlos, 21 years old, and my student ID is S54321\n\nEn este ejemplo:\n\nLivingBeing es la clase base que inicializa el atributo name.\nPerson es una subclase de LivingBeing que inicializa name a través de super().__init__(name) y luego inicializa age.\nStudent es una subclase de Person que inicializa name y age a través de super().__init__(name, age) y luego inicializa student_id.\n\nMétodos que Vienen por Defecto en Python En Python, todas las clases heredan de la clase base object. Esto significa que todas las clases tienen ciertos métodos por defecto, algunos de los cuales pueden ser útiles para personalizar el comportamiento de tus clases.",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>POO: resumen</span>"
    ]
  },
  {
    "objectID": "qmd/python/poo3_resumen.html#métodos-por-defecto-más-comunes",
    "href": "qmd/python/poo3_resumen.html#métodos-por-defecto-más-comunes",
    "title": "18  POO: resumen",
    "section": "18.3 Métodos por Defecto Más Comunes",
    "text": "18.3 Métodos por Defecto Más Comunes\n\n__init__(self): Constructor de la clase. Es llamado cuando se crea una nueva instancia de la clase. Inicializa los atributos del objeto.\n__str__(self): Devuelve una representación en cadena del objeto, utilizada por print() y str(). Este método es útil para proporcionar una representación legible del objeto.\n__repr__(self): Devuelve una representación “oficial” del objeto, utilizada por repr(). Este método está diseñado para devolver una cadena que represente al objeto de manera que se pueda recrear.\n\nEjemplo de Métodos str y repr\nVamos a crear una clase Person que sobrescriba los métodos __str__ y __repr__.\n\nclass Person:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n\n    def __str__(self):\n        return f\"{self.name}, {self.age} años\"\n\n    def __repr__(self):\n        return f\"Person(name={self.name}, age={self.age})\"\n\n# Crear instancias de Person\nperson1 = Person(\"Alice\", 30)\nperson2 = Person(\"Bob\", 25)\n\n# Uso de __str__\nprint(person1)  \n# Output: Alice, 30 años\n\n# Uso de __repr__\nprint(repr(person1))  \n# Output: Person(name=Alice, age=30)\n\nAlice, 30 años\nPerson(name=Alice, age=30)\n\n\nExplicación del Código\n\nEl método __str__ devuelve una representación en cadena del objeto, útil para mensajes de salida amigables.\nEl método __repr__ devuelve una representación más detallada del objeto, útil para la depuración.\nEstos métodos proporcionan una manera conveniente de representar y comparar objetos, lo que facilita la depuración y el uso de los objetos en el código.",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>POO: resumen</span>"
    ]
  },
  {
    "objectID": "qmd/python/json.html",
    "href": "qmd/python/json.html",
    "title": "19  Lectura de archivos JSON",
    "section": "",
    "text": "19.1 Añadir información\nJSON, que significa JavaScript Object Notation, es un formato liviano de intercambio de datos. Es crucial para trabajar con datos en aplicaciones web y APIs. Aprender a manejarlo con Python es esencial para desarrolladores que buscan eficiencia y flexibilidad.\nPara cargar un JSON a python usamos la librería json, en específico, la la función load(),\nUna vez cargado el archivo, podemos iterar sobre el contenido.\nAñadir información a un archivo JSON es tan sencillo como leerlo. Supongamos que quieres añadir un nuevo producto:\n### Este bloque de codigo no se ejecutara en el libro ###\n# Creamos un nuevo producto con la estructura del JSON\nnew_product = {\n    \"name\": \"Wireless Charger\",\n    \"price\": 75,\n    \"quantity\": 100,\n    \"brand\": \"ChargeMaster\",\n    \"category\": \"Accessories\",\n    \"entry_date\": \"2025-06-14\"\n}\n\n# Leemos el archivo\nwith open('Products.json', 'r') as file:\n    products = json.load(file)\n\n# Ingresamos el nuevo producto a la lista con los datos JSON\nproducts.append(new_product)\n\n# Sobreescribimos el archivo\nwith open('Products.json', 'w') as file:\n    json.dump(products, file, indent = 4)",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Lectura de archivos JSON</span>"
    ]
  },
  {
    "objectID": "qmd/python/librerias_modulos.html",
    "href": "qmd/python/librerias_modulos.html",
    "title": "20  Librerías y módulos",
    "section": "",
    "text": "20.1 ¿Qué es la Biblioteca Estándar de Python?\nComo programador, una de las mayores satisfacciones es encontrar la solución perfecta al problema que estás tratando de resolver, y hacerlo de manera eficiente. ¿Te imaginas tener a tu disposición un conjunto de herramientas que te permita escribir menos código pero lograr más? Eso es lo que ofrece la Biblioteca Estándar de Python.\nImagina poder saltar directamente a construir la lógica de tu aplicación sin preocuparte por las tareas rutinarias, porque ya tienes los módulos que necesitas listos para usar. Aquí vamos a explorar cómo la Biblioteca Estándar de Python puede transformar tu manera de programar, dándote acceso inmediato a una vasta colección de herramientas que te permiten concentrarte en lo que realmente importa: resolver problemas de manera elegante y eficaz.\nLa Biblioteca Estándar de Python es como tener un conjunto de herramientas integradas directamente en el lenguaje que te ayudan a realizar una variedad de tareas sin tener que reinventar la rueda. Desde la manipulación de archivos, pasando por cálculos matemáticos complejos, hasta la creación de servidores web, la Biblioteca Estándar tiene módulos que simplifican casi cualquier tarea que te propongas.",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Librerías y módulos</span>"
    ]
  },
  {
    "objectID": "qmd/python/librerias_modulos.html#qué-es-una-librería-y-qué-es-un-módulo",
    "href": "qmd/python/librerias_modulos.html#qué-es-una-librería-y-qué-es-un-módulo",
    "title": "20  Librerías y módulos",
    "section": "20.2 ¿Qué es una Librería y qué es un Módulo?",
    "text": "20.2 ¿Qué es una Librería y qué es un Módulo?\nAntes de sumergirnos en cómo puedes aprovechar la Biblioteca Estándar, aclaremos dos conceptos clave:\n\nLibrería: En Python, una librería es un conjunto organizado de módulos que puedes usar para añadir funcionalidades a tu código sin tener que escribirlas tú mismo. Piensa en ello como una colección de herramientas especializadas listas para usar.\nMódulo: Un módulo es un archivo de Python que contiene código que puedes reutilizar en tus proyectos. Un módulo puede incluir funciones, clases, y variables que te ayudan a resolver problemas específicos de manera eficiente.\n\nEstos conceptos son fundamentales porque la Biblioteca Estándar está compuesta por una amplia variedad de módulos, cada uno diseñado para hacer tu vida como programador más fácil.",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Librerías y módulos</span>"
    ]
  },
  {
    "objectID": "qmd/python/librerias_modulos.html#la-conexión-de-la-biblioteca-estándar-con-tus-proyectos",
    "href": "qmd/python/librerias_modulos.html#la-conexión-de-la-biblioteca-estándar-con-tus-proyectos",
    "title": "20  Librerías y módulos",
    "section": "20.3 La Conexión de la Biblioteca Estándar con tus Proyectos",
    "text": "20.3 La Conexión de la Biblioteca Estándar con tus Proyectos\nLa belleza de la Biblioteca Estándar radica en cómo cada módulo está diseñado para interactuar con otros, permitiéndote construir aplicaciones completas sin tener que buscar soluciones externas. Al trabajar en un proyecto, puedes confiar en que la Biblioteca Estándar tiene las herramientas necesarias para cubrir la mayoría de tus necesidades.\nPor ejemplo, si estás trabajando en una aplicación que necesita interactuar con el sistema de archivos, el módulo os te permite manipular directorios y archivos de manera eficiente. Si tu aplicación necesita realizar operaciones matemáticas complejas, el módulo math ofrece un amplio rango de funciones listas para usar. Cada módulo tiene su propósito, pero todos están diseñados para trabajar juntos y hacer tu código más limpio y eficiente.",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Librerías y módulos</span>"
    ]
  },
  {
    "objectID": "qmd/python/librerias_modulos.html#explorando-áreas-clave-de-la-biblioteca-estándar",
    "href": "qmd/python/librerias_modulos.html#explorando-áreas-clave-de-la-biblioteca-estándar",
    "title": "20  Librerías y módulos",
    "section": "20.4 Explorando Áreas Clave de la Biblioteca Estándar",
    "text": "20.4 Explorando Áreas Clave de la Biblioteca Estándar\nAhora, veamos algunas de las áreas más importantes que cubre la Biblioteca Estándar:\n\nManejo de Archivos y Sistema: Módulos como os, shutil, y pathlib te permiten interactuar con el sistema de archivos, lo cual es esencial para casi cualquier proyecto.\nOperaciones Matemáticas: Módulos como math y random te proporcionan funciones matemáticas avanzadas y generación de números aleatorios.\nManejo de Fechas y Tiempos: datetime y time te permiten trabajar con fechas y horas, lo cual es crucial para la programación de eventos o el registro de actividades.\nManipulación de Datos: Módulos como json y csv son ideales para leer y escribir datos estructurados, algo común en el manejo de APIs y almacenamiento de información.\nRedes y Comunicaciones: Si estás construyendo aplicaciones que necesitan comunicarse a través de una red, socket y http.server te proporcionan las herramientas necesarias para gestionar conexiones y servidores web.\n\nEstos módulos no solo te ahorran tiempo, sino que también te ayudan a escribir código más limpio y mantenible.",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Librerías y módulos</span>"
    ]
  },
  {
    "objectID": "qmd/python/librerias_modulos.html#qué-es-pippip3-y-cuándo-deberíamos-considerar-instalar-una-librería",
    "href": "qmd/python/librerias_modulos.html#qué-es-pippip3-y-cuándo-deberíamos-considerar-instalar-una-librería",
    "title": "20  Librerías y módulos",
    "section": "20.5 ¿Qué es pip/pip3 y Cuándo Deberíamos Considerar Instalar una Librería?",
    "text": "20.5 ¿Qué es pip/pip3 y Cuándo Deberíamos Considerar Instalar una Librería?\nLa Biblioteca Estándar es extremadamente poderosa, pero a veces necesitarás algo más específico o avanzado. Aquí es donde entra pip, una herramienta que te permite instalar librerías adicionales que no vienen incluidas en Python por defecto.\n\n20.5.1 ¿Cuándo deberías considerar instalar una librería?\n\nCuando necesitas funcionalidades que no están cubiertas por la Biblioteca Estándar.\nCuando quieres utilizar herramientas más especializadas para resolver problemas complejos.\nCuando necesitas una versión más reciente o específica de un módulo.\n\nPor ejemplo, si estás trabajando en análisis de datos, podrías necesitar pandas, una librería poderosa para la manipulación y análisis de datos que no está en la Biblioteca Estándar.\n\n\n20.5.2 ¿Cómo Instalar una Librería con pip?\nInstalar una librería con pip es directo y simple. Abre tu terminal y ejecuta:\n\n# Dependiendo de la version de python\npip install nombre-de-la-libreria\npip3 install nombre-de-la-libreria\n\nEsto descargará e instalará la librería desde PyPI, un repositorio en línea donde se alojan miles de librerías para Python, y estará lista para ser utilizada en tu proyecto.",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Librerías y módulos</span>"
    ]
  },
  {
    "objectID": "qmd/python/librerias_ejemplos.html",
    "href": "qmd/python/librerias_ejemplos.html",
    "title": "21  Librerías útiles de sistema",
    "section": "",
    "text": "21.1 os\nInteractuar con el sistema operativo desde Python es una tarea que se hace mucho más sencilla gracias a la librería OS. Sin necesidad de instalaciones adicionales, esta herramienta permite automatizar y manejar archivos y directorios, lo que simplifica enormemente el flujo de trabajo. Veamos algunos ejemplos prácticos de su uso.\n# Importamos la libreria\nimport os",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Librerías útiles de sistema</span>"
    ]
  },
  {
    "objectID": "qmd/python/librerias_ejemplos.html#os",
    "href": "qmd/python/librerias_ejemplos.html#os",
    "title": "21  Librerías útiles de sistema",
    "section": "",
    "text": "Directorio actual\n\nos.getcwd()\n\n'/Users/jona/Github/book-cursos/qmd/python'\n\n\n\n\nListar los archivos del directorio\n\n# Listamos los archivos que comienzan con \"poo\" usando\n# list comprehension\npoo = [files for files in os.listdir(\".\") if files.startswith(\"poo\")]\nprint(f\"Los archivos de POO son: {poo}\")\n\nLos archivos de POO son: ['poo1_clases.qmd', 'poo1_clases.html', 'poo3_resumen.html', 'poo2_herencias.html', 'poo3_resumen.qmd', 'poo2_herencias.qmd']\n\n\n¿Cómo funciona esta list comprehension?\n\nos.listdir(\".\"):\n\n\nDevuelve una lista con todos los archivos y carpetas del directorio actual (el punto “.” representa el directorio actual).\n\n\nfor files in ...:\n\n\nItera sobre cada elemento (archivo/carpeta) de la lista que devuelve os.listdir(“.”)\nLa variable files toma el valor de cada nombre de archivo en cada iteración.\n\n\nif files.startswith(\"poo\"):\n\n\nCondición que filtra solo los archivos cuyo nombre comience con “poo”\nstartswith() devuelve True si el string comienza con el prefijo especificado.\n\n\nfiles (al inicio):\n\n\nEs lo que se incluye en la lista final para cada elemento que cumple la condición.",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Librerías útiles de sistema</span>"
    ]
  },
  {
    "objectID": "qmd/python/librerias_ejemplos.html#math",
    "href": "qmd/python/librerias_ejemplos.html#math",
    "title": "21  Librerías útiles de sistema",
    "section": "21.2 math",
    "text": "21.2 math\nCuando trabajamos con cálculos matemáticos en Python, la librería Math es una aliada invaluable. Ofrece una serie de funciones y constantes matemáticas, ideal para conseguir resultados precisos.\n\nimport math\n\nEjemplos de uso de la librería math:\n\n# 1. Calcular el area y perimetro de una circunferencia\nradio = 5\n\narea = round((math.pi * radio ** 2), 1)\nperimetro = round((2 * math.pi * radio), 1) \n\nprint(f\"El área de un círculo con radio 5 es de: {area}\")\nprint(f\"El perímetro de un círculo con radio 5 es de: {perimetro}\")\n\nEl área de un círculo con radio 5 es de: 78.5\nEl perímetro de un círculo con radio 5 es de: 31.4",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Librerías útiles de sistema</span>"
    ]
  },
  {
    "objectID": "qmd/python/librerias_ejemplos.html#random",
    "href": "qmd/python/librerias_ejemplos.html#random",
    "title": "21  Librerías útiles de sistema",
    "section": "21.3 random",
    "text": "21.3 random\nLa generación de números y elecciones aleatorias es una tarea comúnmente requerida, y la librería Random en Python nos ofrece varias herramientas útiles para este propósito.\n\nimport random\n\nEjemplos de uso de la librería random:\n\n# 1. Generar un numero entero aleatorio entre 1 y 10\nprint(f\"Número entero aleatorio: {random.randint(1, 10)}\")\n\n# 2. Elegir aleatoriamente\n## Con lista\nlista = ['manzana', 'banana', 'cereza']\nprint(\"Elegir un elemento de una lista: \", random.choice(lista))\n\n## Con tupla\ntupla = (10, 20, 30, 40)\nprint(\"Elegir un elemento de una tupla: \",random.choice(tupla))  # ej: 30\n\n## Con string\ncadena = \"ABCDEFG\"\nprint(\"Elegir un elemento de una string: \",random.choice(cadena))  # ej: 'D'\n\n## Con range\nrango = range(1, 11)  # números del 1 al 10\nprint(\"Elegir un elemento de un rango: \",random.choice(rango))\n\nNúmero entero aleatorio: 4\nElegir un elemento de una lista:  banana\nElegir un elemento de una tupla:  30\nElegir un elemento de una string:  C\nElegir un elemento de un rango:  1\n\n\nEjemplo de shuffle\n\n# Lista original\ncartas = ['As', 'Rey', 'Reina', 'Jota', '10', '9']\nprint(\"Original:\", cartas)\n\n# Mezclar la lista\nrandom.shuffle(cartas)\nprint(\"Mezclada:\", cartas)\n\nOriginal: ['As', 'Rey', 'Reina', 'Jota', '10', '9']\nMezclada: ['As', 'Reina', 'Rey', '10', '9', 'Jota']",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Librerías útiles de sistema</span>"
    ]
  },
  {
    "objectID": "qmd/python/librerias_ejemplos.html#statistics",
    "href": "qmd/python/librerias_ejemplos.html#statistics",
    "title": "21  Librerías útiles de sistema",
    "section": "21.4 statistics",
    "text": "21.4 statistics\nEn el análisis de datos, es fundamental comprender y utilizar diversas medidas estadísticas para interpretar correctamente la información. Estas medidas nos permiten resumir y describir las características principales de un conjunto de datos, facilitando la toma de decisiones informadas.\n\nimport statistics\n\nAlgunas de las medidas estadísticas más comunes y sus fórmulas asociadas son las siguientes:\n\n# Datos para ejemplo:\ndatos = [1, 2, 3, 4, 4, 5, 6, 7, 8, 9, 10]\n\n# Media aritmetica: `.mean()`\nprint(\"La media es: \", statistics.mean(datos))\n\n# Mediana (valor central): `.median()`\nprint(\"La mediana es: \", statistics.median(datos))\n\n# Moda (valor mas frecuente): `.mode()`\nprint(\"La moda es: \", statistics.mode(datos))\n\n# Desviacion estandar: `.stdev()`\nprint(\"La desviación estándar es: \", round((statistics.stdev(datos)), 2))\n\n# Varianza de la muestra: `.variance()`\nprint(\"La varianza es: \", round((statistics.variance(datos)), 2))\n\n# Valor minimo: `.min()`\nprint(\"El valor mínimo es: \", min(datos))\n\n# Valor maximo: `.max()`\nprint(\"El valor máximo es: \", max(datos))\n\n# Cuartiles general: `.quantiles()`\nprint(\"Los cuartiles son: \", statistics.quantiles(datos, n = 4))\n\n# Primer cuartil: [N] segun index\nprint(\"El primer cuartil es: \", statistics.quantiles(datos, n = 4)[0])\n\nLa media es:  5.363636363636363\nLa mediana es:  5\nLa moda es:  4\nLa desviación estándar es:  2.91\nLa varianza es:  8.45\nEl valor mínimo es:  1\nEl valor máximo es:  10\nLos cuartiles son:  [3.0, 5.0, 8.0]\nEl primer cuartil es:  3.0",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Librerías útiles de sistema</span>"
    ]
  },
  {
    "objectID": "qmd/python/pythonic.html",
    "href": "qmd/python/pythonic.html",
    "title": "22  Código pythonco",
    "section": "",
    "text": "22.1 Uso general\nEscribir código Pytónico es fundamental para cualquier desarrollador que aspire a trabajar en proyectos grandes y colaborativos. No se trata solo de hacer que el código funcione, sino de garantizar que sea claro, eficiente y mantenible.\nAl dominar estas habilidades, un desarrollador no solo mejora su capacidad para colaborar con otros, sino que también contribuye significativamente a la calidad de los proyectos.\nEste enfoque resalta la importancia de seguir las mejores prácticas de Python, que se describen en el documento PEP8.\nEjemplos de código no pythonico y código sí pythonico para uso general:\n# 1. Iteración sobre listas:\n## No pythónico\nlista = [1, 2, 3, 4, 5]\nfor i in range(len(lista)):\n    print(lista[i])\n\n## Pythónico\nfor elemento in lista:\n    print(elemento)\n\n---------------------------\n\n# 2. Intercambio de variables:\n## No pythónico\ntemp = a\na = b\nb = temp\n\n## Pythónico\na, b = b, a\n\n--------------------------\n\n# 3. List comprehensions:\n## No pythónico\ncuadrados = []\nfor x in range(10):\n    cuadrados.append(x**2)\n\n## Pythónico\ncuadrados = [x**2 for x in range(10)]\n\n--------------------------\n\n# 4. Verificar si una lista está vacía:\n## No pythónico\nif len(lista) == 0:\n    print(\"Lista vacía\")\n\n## Pythónico\nif not lista:\n    print(\"Lista vacía\")\n\n--------------------------\n\n# 5. Usar enumerate() para índices:\n## No pythónico\nnombres = ['Ana', 'Luis', 'María']\nfor i in range(len(nombres)):\n    print(f\"{i}: {nombres[i]}\")\n\n## Pythónico\nfor i, nombre in enumerate(nombres):\n    print(f\"{i}: {nombre}\")\n\n--------------------------\n\n# 6. Manejo de diccionarios:\n## No pythónico\ndiccionario = {'clave': 'valor'}\nif 'clave' in diccionario:\n    valor = diccionario['clave']\nelse:\n    valor = 'por_defecto'\n\n## Pythónico\nvalor = diccionario.get('clave',",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Código pythonco</span>"
    ]
  },
  {
    "objectID": "qmd/python/pythonic.html#clases",
    "href": "qmd/python/pythonic.html#clases",
    "title": "22  Código pythonco",
    "section": "22.2 Clases",
    "text": "22.2 Clases\n\n# 1. Definición de clases:\n## No pythónico - nombres incorrectos\n# PROBLEMA: Nombre de clase en camelCase y atributo con prefijo innecesario\n# SOLUCIÓN: Usar PascalCase para clases y nombres descriptivos para atributos\nclass miClase:\n    def __init__(self, valor):\n        self.mi_valor = valor\n\n## Pythónico - PascalCase para clases\nclass MiClase:\n    def __init__(self, valor):\n        self.valor = valor\n\n--------------------------\n\n# 2. Propiedades vs getters/setters:\n## No pythónico - getters/setters innecesarios\n# PROBLEMA: Usar métodos get/set como en Java, hace el código verboso\n# SOLUCIÓN: Python prefiere acceso directo o propiedades con @property\nclass Persona:\n    def __init__(self, nombre):\n        self._nombre = nombre\n    \n    def get_nombre(self):\n        return self._nombre\n    \n    def set_nombre(self, nombre):\n        self._nombre = nombre\n\n## Pythónico - usar propiedades\nclass Persona:\n    def __init__(self, nombre):\n        self._nombre = nombre\n    \n    @property\n    def nombre(self):\n        return self._nombre\n    \n    @nombre.setter\n    def nombre(self, valor):\n        self._nombre = valor\n\n--------------------------\n\n# 3. Método __str__ vs print manual:\n## No pythónico\n# PROBLEMA: Método personalizado para mostrar info, no reutilizable\n# SOLUCIÓN: Usar __str__ para representación legible y __repr__ para depuración\nclass Producto:\n    def __init__(self, nombre, precio):\n        self.nombre = nombre\n        self.precio = precio\n    \n    def mostrar_info(self):\n        print(f\"{self.nombre}: ${self.precio}\")\n\n## Pythónico - usar __str__ y __repr__\nclass Producto:\n    def __init__(self, nombre, precio):\n        self.nombre = nombre\n        self.precio = precio\n    \n    def __str__(self):\n        return f\"{self.nombre}: ${self.precio}\"\n    \n    def __repr__(self):\n        return f\"Producto({self.nombre!r}, {self.precio})\"\n\n--------------------------\n\n# 4. Herencia y super():\n## No pythónico - llamada directa a clase padre\n# PROBLEMA: Llamar directamente al constructor padre por nombre, \n#            frágil si cambia la herencia\n# SOLUCIÓN: Usar super() que es más flexible y mantenible\nclass Animal:\n    def __init__(self, nombre):\n        self.nombre = nombre\n\nclass Perro(Animal):\n    def __init__(self, nombre, raza):\n        Animal.__init__(self, nombre)  # Rígido y propenso a errores\n        self.raza = raza\n\n## Pythónico - usar super()\nclass Perro(Animal):\n    def __init__(self, nombre, raza):\n        super().__init__(nombre)  # Flexible y mantenible\n        self.raza = raza\n\n--------------------------\n\n# 5. Métodos de clase vs funciones externas:\n## No pythónico\n# PROBLEMA: Función externa para crear instancias, rompe encapsulación\n# SOLUCIÓN: Usar @classmethod para constructores alternativos dentro de la clase\nclass Contador:\n    def __init__(self, valor=0):\n        self.valor = valor\n\ndef crear_contador_desde_string(texto):  # Función suelta, no cohesiva\n    return Contador(len(texto))\n\n## Pythónico - usar @classmethod\nclass Contador:\n    def __init__(self, valor=0):\n        self.valor = valor\n    \n    @classmethod\n    def desde_string(cls, texto):  # Constructor alternativo",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Código pythonco</span>"
    ]
  },
  {
    "objectID": "qmd/python/comm_dockstrings.html",
    "href": "qmd/python/comm_dockstrings.html",
    "title": "23  Comentarios y dockstrings",
    "section": "",
    "text": "23.1 Cosas a evitar\nTrabajar en proyectos grandes y complejos requiere no solo habilidades técnicas sino también la capacidad de comunicar eficazmente dentro del equipo. Mantener la claridad a través de documentación precisa, como comentarios y docstrings, es esencial.\nEsto es similar a roxygen2 en R.\nSi trabajamos en VSCode, al invocar la función y pasar el mouse sobre esta, si dicha función tiene comentarios este te los va a mostrar en una pequeña ventana.",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Comentarios y dockstrings</span>"
    ]
  },
  {
    "objectID": "qmd/python/comm_dockstrings.html#cosas-a-evitar",
    "href": "qmd/python/comm_dockstrings.html#cosas-a-evitar",
    "title": "23  Comentarios y dockstrings",
    "section": "",
    "text": "Redundancia: No repitas lo que ya es evidente en el nombre de la función o la operación realizada. Si el nombre de la función ya indica que calcula el área de un triángulo, un comentario adicional que repita esta información es innecesario.\nSobreinformar: Incluir demasiada información puede llegar a confundir en lugar de aclarar. Recuerda, los comentarios deben añadir valor al código, no abarrotarlo de explicaciones obvias.",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Comentarios y dockstrings</span>"
    ]
  },
  {
    "objectID": "qmd/python/var_local_global.html",
    "href": "qmd/python/var_local_global.html",
    "title": "24  Variables locales y globales",
    "section": "",
    "text": "En el fascinante mundo de la programación, comprender la vida útil de una variable es vital para evitar errores comunes y mejorar el rendimiento del código. Las variables locales y globales juegan un papel crucial en este ámbito.\nMientras que las variables locales existen sólo dentro de un bloque de código determinado, las variables globales pueden ser accedidas desde cualquier parte del programa.\nLas variables nonlocal actúan como un puente entre variables locales y globales, permitiendo que las funciones internas accedan y modifiquen variables en funciones ‘encapsulantes’ externas.\n\ndef funcion_externa():\n    x = \"inicial\"\n\n    def funcion_interna():\n        nonlocal x\n        x = \"modificado\"\n        print(\"El valor en inner es\", x)\n\n    funcion_interna()\n    print(\"El valor afuera es\", x)\n\nfuncion_externa()\n\nEl valor en inner es modificado\nEl valor afuera es modificado",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Variables locales y globales</span>"
    ]
  },
  {
    "objectID": "qmd/python/anotaciones.html",
    "href": "qmd/python/anotaciones.html",
    "title": "25  Anotaciones",
    "section": "",
    "text": "25.1 En variables\nLas anotaciones en Python son una herramienta que permite agregar información adicional sobre las variables, funciones y métodos que programamos. Aunque no restringen el tipo de datos que se puede almacenar en una variable, proporcionan un contexto más claro sobre el objetivo del código, beneficiando la legibilidad y comprensión, especialmente en entornos de trabajo en equipo.\nLas anotaciones para las variables consisten en especificar el tipo esperado usando dos puntos seguidos de la declaración del tipo. Por ejemplo, al crear un identificador para empleados, podríamos especificarlo de la siguiente manera:\nid1: int = 101\nid2: int = 102",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Anotaciones</span>"
    ]
  },
  {
    "objectID": "qmd/python/anotaciones.html#en-funciones",
    "href": "qmd/python/anotaciones.html#en-funciones",
    "title": "25  Anotaciones",
    "section": "25.2 En funciones",
    "text": "25.2 En funciones\nEn las funciones, las anotaciones ayudan a definir los tipos de datos que los parámetros deben recibir y el tipo de dato que devolverá la función. La sintaxis se asemeja a esto:\n\n# Aqui estipulamos lo que se espera para los parametros\n# y el resultado deberia ser un entero\ndef sumar_ids_empleados(id1: int, id2: int) -&gt; int:\n    return id1 + id2",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Anotaciones</span>"
    ]
  },
  {
    "objectID": "qmd/python/anotaciones.html#en-clases",
    "href": "qmd/python/anotaciones.html#en-clases",
    "title": "25  Anotaciones",
    "section": "25.3 En clases",
    "text": "25.3 En clases\nAl trabajar con clases, las anotaciones ayudan a definir tipos de los atributos y métodos.\n\nclass Empleado:\n    def __init__(self, nombre: str, edad: int, salario: float):\n        self.nombre = nombre\n        self.edad = edad\n        self.salario = salario\n\n    def presentarse(self) -&gt; str:\n        return f\"Hola, me llamo {self.nombre}. Tengo {self.edad} años.\"",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Anotaciones</span>"
    ]
  },
  {
    "objectID": "qmd/python/anotaciones.html#optional-y-union",
    "href": "qmd/python/anotaciones.html#optional-y-union",
    "title": "25  Anotaciones",
    "section": "25.4 Optional y Union",
    "text": "25.4 Optional y Union\nLas librerías Optional y Union permiten mayor flexibilidad en las anotaciones al trabajar con funciones que pueden manejar múltiples tipos de datos o retornar None.\n\nfrom typing import Optional\n\ndef buscar_usuario(id_usuario: int) -&gt; Optional[str]:\n    \"\"\"\n    Busca un usuario por ID.\n    Retorna el nombre del usuario o None si no existe.\n    \"\"\"\n    usuarios = {1: \"Ana\", 2: \"Luis\", 3: \"María\"}\n    \n    if id_usuario in usuarios:\n        return usuarios[id_usuario]  # Retorna str\n    else:\n        return None  # Retorna None\n\n# Uso de la función\nnombre = buscar_usuario(1)  # tipo: Optional[str]\nprint(nombre)  # \"Ana\"\n\nnombre = buscar_usuario(99)  # tipo: Optional[str] \nprint(nombre)  # None",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Anotaciones</span>"
    ]
  },
  {
    "objectID": "qmd/python/validaciones.html",
    "href": "qmd/python/validaciones.html",
    "title": "26  Validaciones de datos",
    "section": "",
    "text": "La validación de tipos y manejo de excepciones en Python es esencial, sobre todo en proyectos colaborativos o críticos donde los datos externos juegan un papel crucial.\n\n\n\n\n\n\nImportant\n\n\n\nAunque Python permite especificar tipos de datos para los parámetros de una función (capítulo anterior), no garantiza que estos sean correctos en tiempo de ejecución.\n\n\nPara realizar esto utilizamos la función isinstance, que verifica si un objeto es una instancia de una clase específica o de cualquiera de las clases especificadas. Devuelve True si la condición se cumple, False en caso contrario.\n\ndef dividir(a, b):\n\n    # Validar que ambos valores rean enteros:\n    #  not isinstance(a, int) = \"Si no es entero\"\n    if not isinstance(a, int) or not isinstance(b, int):\n        raise TypeError(\"Ambos parámetros deben ser enteros\")\n        return None\n\n    # Validar que no se pueda dividir por 0\n    if b == 0:\n        raise ValueError(\"El divisor no puede ser cero\")\n    \n    # Retornar el resultado\n    return a / b\n\n# Error de tipo de dato\ndividir(a = 4, b = 2.2)\n# TypeError: Ambos parámetros deben ser enteros\n\n\ndividir(a = 4, b = 0)\n# ValueError: El divisor no puede ser cero",
    "crumbs": [
      "Python",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Validaciones de datos</span>"
    ]
  }
]